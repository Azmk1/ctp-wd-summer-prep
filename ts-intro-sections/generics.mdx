import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## Arrays and Generics

- Arrays can be typed in two ways
- Generics allow types to be flexible but safe
- Think of generics as "type functions" with argument types and a return type

```typescript
// Two ways to type arrays
let numbers: number[] = [1, 2, 3];
let strings: Array<string> = ["a", "b", "c"];

// Generic function
function identity<T>(value: T): T {
  return value;
}

identity<string>("hello"); // Returns string
identity<number>(42); // Returns number
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Build a Generic Container

```typescript
// Create a generic Box class that can hold any type of value
// It should have methods to get and set the value

class Box {
  // TODO: Make this generic!
  private value: any;
  
  constructor(initial: any) {
    this.value = initial;
  }
  
  getValue(): any {
    return this.value;
  }
  
  setValue(newValue: any): void {
    this.value = newValue;
  }
}

// This should work with proper generics
const numberBox = new Box(42);
const num: number = numberBox.getValue(); // Should be type-safe

const stringBox = new Box("hello");
const str: string = stringBox.getValue(); // Should be type-safe

//***
describe('Generic Box - Initial Implementation', () => {
  it('should store and retrieve values', () => {
    const testBox = new Box(100);
    expect(testBox.getValue()).to.equal(100);
  });
  
  it('should update values correctly', () => {
    const testBox = new Box(100);
    testBox.setValue(200);
    expect(testBox.getValue()).to.equal(200);
  });
});
// ---
// Step 1: Add generic type parameter
class Box<T> {
  private value: T;
  
  constructor(initial: T) {
    this.value = initial;
  }
  
  getValue(): T {
    return this.value;
  }
  
  setValue(newValue: T): void {
    this.value = newValue;
  }
}

// Now it's type-safe!
const numberBox = new Box<number>(42);
const num: number = numberBox.getValue(); // Type-safe!
// numberBox.setValue("wrong"); // Error!

const stringBox = new Box("hello"); // Type inferred
const str: string = stringBox.getValue();

//***
describe('Generic Box - Step 1: Type safety', () => {
  it('should maintain number type', () => {
    const numBox = new Box(42);
    expect(typeof numBox.getValue()).to.equal('number');
    expect(numBox.getValue()).to.equal(42);
  });
  
  it('should maintain string type', () => {
    const strBox = new Box("test");
    expect(typeof strBox.getValue()).to.equal('string');
    expect(strBox.getValue()).to.equal("test");
  });
  
  it('should infer array type correctly', () => {
    const inferredBox = new Box([1, 2, 3]);
    const array = inferredBox.getValue();
    expect(Array.isArray(array)).to.be.true;
    expect(array).to.deep.equal([1, 2, 3]);
  });
});
// ---
// Step 2: Add map method
class Box<T> {
  private value: T;
  
  constructor(initial: T) {
    this.value = initial;
  }
  
  getValue(): T {
    return this.value;
  }
  
  setValue(newValue: T): void {
    this.value = newValue;
  }
  
  // Transform the value to a different type
  map<U>(fn: (value: T) => U): Box<U> {
    return new Box(fn(this.value));
  }
  
  // Check if value meets condition
  filter(predicate: (value: T) => boolean): Box<T | null> {
    return new Box(predicate(this.value) ? this.value : null);
  }
}

// Use the map method
const numberBox = new Box(42);
const stringBox = numberBox.map(n => n.toString());
const boolBox = numberBox.map(n => n > 40);

console.log(stringBox.getValue()); // "42"
console.log(boolBox.getValue()); // true

//***
describe('Generic Box - Step 2: Transformation methods', () => {
  let box;
  
  before(() => {
    box = new Box(10);
  });
  
  it('should transform value with map', () => {
    const doubled = box.map(x => x * 2);
    expect(doubled.getValue()).to.equal(20);
  });
  
  it('should work with different return types in map', () => {
    const stringified = box.map(x => `Value: ${x}`);
    expect(stringified.getValue()).to.equal("Value: 10");
  });
  
  it('should keep value when filter predicate is true', () => {
    const filtered = box.filter(x => x > 5);
    expect(filtered.getValue()).to.equal(10);
  });
  
  it('should return null when filter predicate is false', () => {
    const filteredOut = box.filter(x => x > 20);
    expect(filteredOut.getValue()).to.be.null;
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Generic Constraints

```typescript
// Constrain generics to certain types
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(item: T): T {
  console.log(item.length);
  return item;
}

logLength("hello"); // OK - strings have length
logLength([1, 2, 3]); // OK - arrays have length
logLength({ length: 10 }); // OK - has length property
// logLength(123); // Error - numbers don't have length

// Multiple constraints
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Built-in Generic Types

```typescript
// Promise<T> - Async values
const promise: Promise<string> = fetch('/api').then(r => r.text());

// Array<T> - Lists of values
const numbers: Array<number> = [1, 2, 3];

// Map<K, V> - Key-value pairs
const userMap: Map<number, string> = new Map();
userMap.set(1, "Alice");

// Set<T> - Unique values
const uniqueNumbers: Set<number> = new Set([1, 2, 2, 3]);

// Record<K, V> - Object with specific key/value types
const scores: Record<string, number> = {
  alice: 100,
  bob: 95
};
```
</SlideLayout.Center>