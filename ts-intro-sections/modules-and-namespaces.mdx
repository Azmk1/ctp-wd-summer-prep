import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## TypeScript Modules

- ES6 module syntax with type safety
- Import/export types and interfaces
- Module resolution strategies
- Namespaces (legacy, but still used)

```typescript
// math.ts
export interface MathOperation {
  execute(a: number, b: number): number;
}

export class Addition implements MathOperation {
  execute(a: number, b: number): number {
    return a + b;
  }
}

export const PI = 3.14159;
export type NumberPair = [number, number];
```
</SlideLayout.Center>

<SlideLayout.Center>
## Importing and Exporting

```typescript
// Named imports
import { Addition, PI, NumberPair } from './math';

// Import all as namespace
import * as MathUtils from './math';

// Import type only (removed at compile time)
import type { MathOperation } from './math';

// Re-export
export { Addition as Add } from './math';
export * from './math';

// Default export/import
export default class Calculator { }
import Calculator from './calculator';
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Create a Module System

```typescript
// Test setup
let logSpy: sinon.SinonSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

// ***
// Create a validation module with various validators

// TODO: Create these exports in a validation module
// - EmailValidator class
// - PhoneValidator class  
// - ValidationResult type
// - validate function that uses validators

// Simulating module exports (in real code, these would be in separate files)
class EmailValidator {
  validate(email: string): boolean {
    // TODO: Implement
    return false;
  }
}

class PhoneValidator {
  validate(phone: string): boolean {
    // TODO: Implement
    return false;
  }
}

type ValidationResult = {
  isValid: boolean;
  errors?: string[];
};

function validate(value: string, type: 'email' | 'phone'): ValidationResult {
  // TODO: Implement
  return { isValid: false };
}

// Usage
const emailResult = validate('user@example.com', 'email');
const phoneResult = validate('123-456-7890', 'phone');

console.log(emailResult);
console.log(phoneResult);

// ***
describe('Validation Module', () => {
  it('should validate emails', () => {
    const validator = new EmailValidator();
    expect(validator.validate('test@example.com')).to.be.false; // Not implemented yet
  });
  
  it('should validate phone numbers', () => {
    const validator = new PhoneValidator();
    expect(validator.validate('123-456-7890')).to.be.false; // Not implemented yet
  });
});
// ---
// Test setup (reuse)
let logSpy: sinon.SinonSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

// ***
// Step 1: Implement validators
export interface Validator {
  validate(value: string): boolean;
  getErrorMessage(): string;
}

export class EmailValidator implements Validator {
  private emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  validate(email: string): boolean {
    return this.emailRegex.test(email);
  }
  
  getErrorMessage(): string {
    return 'Invalid email format';
  }
}

export class PhoneValidator implements Validator {
  private phoneRegex = /^\d{3}-\d{3}-\d{4}$/;
  
  validate(phone: string): boolean {
    return this.phoneRegex.test(phone);
  }
  
  getErrorMessage(): string {
    return 'Phone must be in format: XXX-XXX-XXXX';
  }
}

export type ValidationResult = {
  isValid: boolean;
  errors?: string[];
};

export function validate(value: string, type: 'email' | 'phone'): ValidationResult {
  const validators: Record<string, Validator> = {
    email: new EmailValidator(),
    phone: new PhoneValidator()
  };
  
  const validator = validators[type];
  const isValid = validator.validate(value);
  
  return {
    isValid,
    errors: isValid ? undefined : [validator.getErrorMessage()]
  };
}

// Test the module
const emailResult = validate('user@example.com', 'email');
const phoneResult = validate('123-456-7890', 'phone');
const invalidEmail = validate('not-an-email', 'email');

console.log(emailResult);
console.log(phoneResult);
console.log(invalidEmail);

// ***
describe('Validation Module Implementation', () => {
  it('should validate correct emails', () => {
    const validator = new EmailValidator();
    expect(validator.validate('test@example.com')).to.be.true;
    expect(validator.validate('user.name+tag@domain.co.uk')).to.be.true;
  });
  
  it('should reject invalid emails', () => {
    const validator = new EmailValidator();
    expect(validator.validate('not-an-email')).to.be.false;
    expect(validator.validate('@example.com')).to.be.false;
    expect(validator.validate('user@')).to.be.false;
  });
  
  it('should validate correct phone numbers', () => {
    const validator = new PhoneValidator();
    expect(validator.validate('123-456-7890')).to.be.true;
    expect(validator.validate('555-123-4567')).to.be.true;
  });
  
  it('should reject invalid phone numbers', () => {
    const validator = new PhoneValidator();
    expect(validator.validate('1234567890')).to.be.false;
    expect(validator.validate('123-45-6789')).to.be.false;
  });
  
  it('should return proper validation results', () => {
    expect(emailResult.isValid).to.be.true;
    expect(emailResult.errors).to.be.undefined;
    
    expect(phoneResult.isValid).to.be.true;
    expect(phoneResult.errors).to.be.undefined;
    
    expect(invalidEmail.isValid).to.be.false;
    expect(invalidEmail.errors).to.deep.equal(['Invalid email format']);
  });
  
  it('should log validation results', () => {
    expect(logSpy.callCount).to.equal(3);
    expect(logSpy.firstCall.args[0]).to.deep.equal({ isValid: true });
    expect(logSpy.secondCall.args[0]).to.deep.equal({ isValid: true });
    expect(logSpy.thirdCall.args[0]).to.have.property('errors');
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Namespaces (Legacy)

```typescript
// Still used in some codebases and declaration files
namespace Validation {
  export interface Validator {
    isValid(value: string): boolean;
  }
  
  export class StringValidator implements Validator {
    isValid(value: string): boolean {
      return value.length > 0;
    }
  }
}

// Using namespace
const validator = new Validation.StringValidator();

// Can be split across files
namespace Validation {
  export class NumberValidator implements Validator {
    isValid(value: string): boolean {
      return !isNaN(Number(value));
    }
  }
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Module Resolution

```typescript
// tsconfig.json moduleResolution options
{
  "compilerOptions": {
    "moduleResolution": "node", // or "classic"
    "baseUrl": "./src",
    "paths": {
      "@utils/*": ["utils/*"],
      "@components/*": ["components/*"]
    }
  }
}

// Now you can import with aliases
import { Helper } from '@utils/helper';
import { Button } from '@components/Button';

// Ambient modules (for non-TS libraries)
declare module 'some-js-library' {
  export function doSomething(): void;
}
```
</SlideLayout.Center>