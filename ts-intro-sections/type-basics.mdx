import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## The Power of Intellisense

- TypeScript tells us about values as we type
- As you're typing `'20%'`, VSCode will give you the error inline
- TypeScript gives your editor additional super-powers, like:
  - Finding all references to a value
  - Seeing what properties an object has
  - Renaming a property across the entire codebase
</SlideLayout.Center>

<SlideLayout.Full>
## Intellisense in Action
```typescript
type User = {
  /** The name of the user, duh */
  name: string;
  /** How old they be */
  age: number;
  /** Are they the creator of the multiverse? */
  isAdmin: boolean;
}

const user: User = {
  name: "Ryan",
  age: 30,
  isAdmin: false,
};
```

</SlideLayout.Full>

<SlideLayout.Full>
## TypeScript's Type System
  <FlexBox alignItems="center" justifyContent="center" flexDirection="row">
    <Box width="100%" height="100%">
      - `undefined`
      - `null`
      - `boolean`
      - `number`
      - `bigint`
      - `string`
      - `symbol`
    </Box>
    <Box width="100%" height="100%">
      - `object`
      - `Function`
      - `Array`
      - `Tuple`
      - `any`
      - `unknown`
      - `never`
    </Box>
  </FlexBox>
</SlideLayout.Full>
<SlideLayout.Full>
## TypeScript's Type System In Action
```typescript
let undef: undefined
let nil = null
let bool = true
let num = 42
let big = 9007199254740991n
let str = "Hello, TypeScript!"
let sym = Symbol("unique")
let obj = { key: "value" }
let func = () => console.log("Hello, Function!")
let arr = [1, 2, 3]
let tuple = ["TypeScript", 4] as [string, number]
let anyValue = "Can be anything" as any
let unknownValue = "Could be anything, but we don't know yet" as unknown
let neverValue = (() => { throw new Error("This should never happen") })()
```
</SlideLayout.Full>

<SlideLayout.Center>
## Type Inference

- TypeScript is smart enough to figure out types on its own
- You don't always need to explicitly write types
- TypeScript will infer types from the values you assign
- This makes TypeScript feel more like JavaScript

```typescript
// TypeScript knows this is a string
let message = "Hello, TypeScript!";

// TypeScript knows this returns a number
function add(a: number, b: number) {
  return a + b;
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Type Inference Challenge

```typescript
// Test setup
let logSpy: sinon.SinonSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// What types does TypeScript infer for these?
// Try to guess before checking!
const score = 100;
const name = "Player One";
const isWinner = score > 50;
const items = [1, 2, 3];
const mixed = [1, "two", true];

function multiply(x: number, y: number) {
  return x * y;
}

const result = multiply(5, 10);

//***
describe('Type Inference Challenge', () => {
  it('should infer primitive types correctly', () => {
    expect(typeof score).to.equal('number');
    expect(typeof name).to.equal('string');
    expect(typeof isWinner).to.equal('boolean');
  });
  
  it('should infer array types', () => {
    expect(Array.isArray(items)).to.be.true;
    expect(items.every(item => typeof item === 'number')).to.be.true;
    
    expect(Array.isArray(mixed)).to.be.true;
    expect(mixed.length).to.equal(3);
  });
  
  it('should infer function return types', () => {
    expect(typeof result).to.equal('number');
    expect(result).to.equal(50);
  });
  
  it('should handle const assertions', () => {
    // TypeScript infers literal types for const
    const literalScore = 100 as const;
    expect(literalScore).to.equal(100);
  });
});
// ---
// Test setup (reuse)
let logSpy: sinon.SinonSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 1: Understanding inferred types
const score = 100; // number
const name = "Player One"; // string
const isWinner = score > 50; // boolean
const items = [1, 2, 3]; // number[]
const mixed = [1, "two", true]; // (string | number | boolean)[]

function multiply(x: number, y: number) {
  return x * y; // Return type inferred as number
}

const result = multiply(5, 10); // number

// TypeScript is smart!
const user = {
  id: 1,
  name: "Alice",
  scores: [95, 87, 92]
}; // { id: number; name: string; scores: number[] }

console.log(user);

//***
describe('Complex Type Inference', () => {
  it('should infer object types correctly', () => {
    expect(user.id).to.equal(1);
    expect(user.name).to.equal("Alice");
    expect(user.scores).to.deep.equal([95, 87, 92]);
  });
  
  it('should infer nested array types', () => {
    expect(user.scores).to.be.an('array');
    expect(user.scores.every(s => typeof s === 'number')).to.be.true;
  });
  
  it('should infer union types for mixed arrays', () => {
    expect(mixed).to.include(1);
    expect(mixed).to.include("two");
    expect(mixed).to.include(true);
  });
  
  it('should log the user object', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.deep.equal(user);
  });
});
// ---
// Test setup (reuse)
let logSpy: sinon.SinonSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 2: When to add explicit types
// Sometimes inference isn't enough
let value; // any - TypeScript doesn't know!
value = 42;
value = "hello"; // No error because it's 'any'

// Better: Be explicit when needed
let betterValue: number;
betterValue = 42;
// betterValue = "hello"; // Error!

// Function parameters need types
function greet(name: string) {
  return `Hello, ${name}!`;
}

// But return types are often inferred
function calculate(a: number, b: number) {
  return a + b; // TypeScript knows this returns number
}

console.log(greet("TypeScript"));
console.log(calculate(10, 20));

//***
describe('Explicit vs Inferred Types', () => {
  it('should handle explicit type annotations', () => {
    let explicitNumber: number = 42;
    let inferredNumber = 42;
    
    expect(typeof explicitNumber).to.equal(typeof inferredNumber);
    expect(explicitNumber).to.equal(inferredNumber);
  });
  
  it('should infer function return types', () => {
    const greeting = greet("TypeScript");
    expect(typeof greeting).to.equal('string');
    expect(greeting).to.equal("Hello, TypeScript!");
    
    const sum = calculate(10, 20);
    expect(typeof sum).to.equal('number');
    expect(sum).to.equal(30);
  });
  
  it('should allow any type to hold different values', () => {
    expect(value).to.equal("hello");
    value = { test: true };
    expect(value).to.deep.equal({ test: true });
  });
  
  it('should log function results', () => {
    expect(logSpy.calledTwice).to.be.true;
    expect(logSpy.firstCall.args[0]).to.equal("Hello, TypeScript!");
    expect(logSpy.secondCall.args[0]).to.equal(30);
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## The Special Types: any, unknown, never

```typescript
// any: Turns off type checking (avoid when possible!)
let anything: any = 42;
anything = "now I'm a string";
anything = { surprise: true };

// unknown: Safe any - must check before use
let mystery: unknown = getValue();
if (typeof mystery === 'string') {
  console.log(mystery.toUpperCase()); // OK after check
}

// never: Represents values that never occur
function throwError(message: string): never {
  throw new Error(message);
}
```
</SlideLayout.Center>