import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## Utility Types

- TypeScript provides built-in utility types
- Transform existing types into new ones
- Save time and make code more maintainable

```typescript
// Partial<T> - Makes all properties optional
interface User {
  id: number;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;
// Same as: { id?: number; name?: string; email?: string; }

function updateUser(id: number, updates: Partial<User>) {
  // Can update any subset of properties
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Common Utility Types

```typescript
// Required<T> - Makes all properties required
type RequiredUser = Required<PartialUser>;

// Readonly<T> - Makes all properties readonly
type ReadonlyUser = Readonly<User>;

// Pick<T, K> - Pick specific properties
type UserCredentials = Pick<User, 'email' | 'password'>;

// Omit<T, K> - Omit specific properties
type PublicUser = Omit<User, 'password'>;

// Record<K, T> - Create object type with keys K and values T
type UserRoles = Record<string, 'admin' | 'user' | 'guest'>;
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Build a CRUD Type System

```typescript
// Create types for a CRUD API using utility types

interface User {
  id: string;
  email: string;
  password: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

// TODO: Create these types using utility types
type CreateUserInput = any; // Should exclude id, createdAt, updatedAt
type UpdateUserInput = any; // Should make all fields optional except id
type PublicUserData = any; // Should exclude password
type UserSummary = any; // Should only have id and name

// These should work when types are correct
const createData: CreateUserInput = {
  email: "user@example.com",
  password: "secret",
  name: "John Doe"
};

const updateData: UpdateUserInput = {
  name: "Jane Doe" // Can update just name
};

// ***
// Test: Types should be correctly derived
// @ts-expect-error - id should not be in CreateUserInput
const badCreate: CreateUserInput = { id: "123" };

// @ts-expect-error - password should not be in PublicUserData  
const badPublic: PublicUserData = { password: "secret" };
// ---
// Step 1: Use Omit and Partial
type CreateUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;
type UpdateUserInput = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;
type PublicUserData = Omit<User, 'password'>;
type UserSummary = Pick<User, 'id' | 'name'>;

// Test the types
const createData: CreateUserInput = {
  email: "user@example.com",
  password: "secret",
  name: "John Doe"
};

const updateData: UpdateUserInput = {
  name: "Jane Doe"
};

const publicData: PublicUserData = {
  id: "123",
  email: "user@example.com",
  name: "John Doe",
  createdAt: new Date(),
  updatedAt: new Date()
};

// ***
describe('CRUD Types - Step 1: Basic utility types', () => {
  it('should create UserSummary with only id and name', () => {
    const summary: UserSummary = { id: "1", name: "Test" };
    expect(summary.id).to.equal("1");
    expect(summary.name).to.equal("Test");
  });
  
  it('should allow empty update object', () => {
    const validUpdate: UpdateUserInput = {}; // All fields optional
    expect(validUpdate).to.be.an('object');
  });
  
  it('should allow partial updates', () => {
    const fullUpdate: UpdateUserInput = {
      email: "new@example.com",
      password: "newpass",
      name: "New Name"
    };
    expect(fullUpdate.email).to.equal("new@example.com");
  });
});
// ---
// Step 2: Create a generic CRUD type generator
type CRUDTypes<T extends { id: string; createdAt: Date; updatedAt: Date }> = {
  Create: Omit<T, 'id' | 'createdAt' | 'updatedAt'>;
  Update: Partial<Omit<T, 'id' | 'createdAt' | 'updatedAt'>>;
  Response: T;
};

// Generate all CRUD types at once
type UserCRUD = CRUDTypes<User>;

// Extract individual types
type CreateUser = UserCRUD['Create'];
type UpdateUser = UserCRUD['Update'];
type UserResponse = UserCRUD['Response'];

// Works with any entity!
interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
  createdAt: Date;
  updatedAt: Date;
}

type ProductCRUD = CRUDTypes<Product>;

// ***
describe('CRUD Types - Step 2: Generic implementation', () => {
  it('should create product without system fields', () => {
    const createProduct: ProductCRUD['Create'] = {
      name: "Widget",
      price: 29.99,
      stock: 100
    };
    
    expect(createProduct.name).to.equal("Widget");
    expect(createProduct.price).to.equal(29.99);
    expect('id' in createProduct).to.be.false;
  });
  
  it('should allow partial product updates', () => {
    const updateProduct: ProductCRUD['Update'] = {
      price: 24.99 // Can update just price
    };
    
    expect(updateProduct.price).to.equal(24.99);
    expect(Object.keys(updateProduct)).to.have.length(1);
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Advanced Utility Types

```typescript
// Extract<T, U> - Extract types assignable to U
type StringOrNumber = string | number | boolean;
type OnlyStringOrNumber = Extract<StringOrNumber, string | number>;
// Result: string | number

// Exclude<T, U> - Exclude types assignable to U
type NotBoolean = Exclude<StringOrNumber, boolean>;
// Result: string | number

// NonNullable<T> - Remove null and undefined
type MaybeString = string | null | undefined;
type DefinitelyString = NonNullable<MaybeString>;
// Result: string

// ReturnType<T> - Extract return type of function
function getData() { return { id: 1, name: "test" }; }
type Data = ReturnType<typeof getData>;
// Result: { id: number; name: string; }
```
</SlideLayout.Center>