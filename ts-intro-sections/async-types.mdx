import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## Async/Await Types

- Promises and async functions have special types
- TypeScript tracks what a Promise resolves to
- Helps catch async errors at compile time

```typescript
async function fetchUser(id: number): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// TypeScript knows user is of type User
const user = await fetchUser(1);
console.log(user.name); // ✅
console.log(user.invalid); // ❌ Error!
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Type-Safe API Client

```typescript
// Create a type-safe API client for a todo app

interface Todo {
  id: number;
  title: string;
  completed: boolean;
  userId: number;
}

interface CreateTodoInput {
  title: string;
  userId: number;
}

// TODO: Implement this class with proper types
class TodoAPI {
  private baseUrl = 'https://jsonplaceholder.typicode.com';
  
  async getTodos() {
    // Fetch all todos
  }
  
  async getTodo(id: number) {
    // Fetch single todo
  }
  
  async createTodo(input: CreateTodoInput) {
    // Create new todo
  }
  
  async updateTodo(id: number, updates: Partial<Todo>) {
    // Update existing todo
  }
}

// Usage
const api = new TodoAPI();
const todos = await api.getTodos();
const newTodo = await api.createTodo({ title: "Learn TypeScript", userId: 1 });

//***
describe('Todo API - Initial Implementation', () => {
  let testApi;
  let fetchStub;
  
  before(() => {
    testApi = new TodoAPI();
    fetchStub = sinon.stub(global, 'fetch');
  });
  
  after(() => {
    fetchStub.restore();
  });
  
  it('should return array from getTodos', async () => {
    fetchStub.resolves({
      json: () => Promise.resolve([{ id: 1, title: "Test", completed: false, userId: 1 }])
    });
    
    const result = await testApi.getTodos();
    expect(result).to.be.an('array');
  });
});
// ---
// Step 1: Basic implementation
class TodoAPI {
  private baseUrl = 'https://jsonplaceholder.typicode.com';
  
  async getTodos(): Promise<Todo[]> {
    const response = await fetch(`${this.baseUrl}/todos`);
    return response.json();
  }
  
  async getTodo(id: number): Promise<Todo | null> {
    try {
      const response = await fetch(`${this.baseUrl}/todos/${id}`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  
  async createTodo(input: CreateTodoInput): Promise<Todo> {
    const response = await fetch(`${this.baseUrl}/todos`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...input, completed: false })
    });
    return response.json();
  }
  
  async updateTodo(id: number, updates: Partial<Todo>): Promise<Todo | null> {
    try {
      const response = await fetch(`${this.baseUrl}/todos/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
}

//***
describe('Todo API - Step 1: Type safety', () => {
  let api;
  
  before(() => {
    api = new TodoAPI();
  });
  
  it('should infer correct types for all methods', async () => {
    // These should have correct types inferred
    const todos: Todo[] = await api.getTodos();
    const todo: Todo | null = await api.getTodo(1);
    const created: Todo = await api.createTodo({ title: "Test", userId: 1 });
    const updated: Todo | null = await api.updateTodo(1, { completed: true });
    
    // Type checking would happen at compile time
    // These tests verify runtime behavior matches expected types
    expect(todos).to.satisfy(() => true); // Type checking happens at compile time
    expect(todo).to.satisfy(() => true);
    expect(created).to.satisfy(() => true);
    expect(updated).to.satisfy(() => true);
  });
});
// ---
// Step 2: Add error handling with Result type
type ApiResult<T> = 
  | { success: true; data: T }
  | { success: false; error: string };

class TodoAPI {
  private baseUrl = 'https://jsonplaceholder.typicode.com';
  
  private async request<T>(url: string, options?: RequestInit): Promise<ApiResult<T>> {
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        return { 
          success: false, 
          error: `HTTP ${response.status}: ${response.statusText}` 
        };
      }
      
      const data = await response.json();
      return { success: true, data };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }
  
  async getTodos(): Promise<ApiResult<Todo[]>> {
    return this.request<Todo[]>(`${this.baseUrl}/todos`);
  }
  
  async getTodo(id: number): Promise<ApiResult<Todo>> {
    return this.request<Todo>(`${this.baseUrl}/todos/${id}`);
  }
  
  async createTodo(input: CreateTodoInput): Promise<ApiResult<Todo>> {
    return this.request<Todo>(`${this.baseUrl}/todos`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...input, completed: false })
    });
  }
  
  async updateTodo(id: number, updates: Partial<Todo>): Promise<ApiResult<Todo>> {
    return this.request<Todo>(`${this.baseUrl}/todos/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates)
    });
  }
}

// Better usage with error handling
const api = new TodoAPI();
const result = await api.getTodos();

if (result.success) {
  console.log(`Found ${result.data.length} todos`);
  result.data.forEach(todo => {
    console.log(`- ${todo.title}`);
  });
} else {
  console.error(`Failed to fetch todos: ${result.error}`);
}

//***
describe('Todo API - Step 2: Error handling', () => {
  let api;
  
  before(() => {
    api = new TodoAPI();
  });
  
  it('should handle successful response correctly', async () => {
    const testResult = await api.getTodo(1);
    
    if (testResult.success) {
      // TypeScript knows data exists here
      const todo: Todo = testResult.data;
      expect(todo).to.have.property('title');
    } else {
      // This branch would be for error cases
      expect.fail('Expected successful response');
    }
  });
  
  it('should handle error response correctly', async () => {
    // In a real test, we'd mock a failed response
    // For now, we verify the error type structure
    const errorResult: ApiResult<Todo> = { success: false, error: 'Test error' };
    
    if (!errorResult.success) {
      // TypeScript knows error exists here
      const error: string = errorResult.error;
      expect(error).to.be.a('string');
      expect(error).to.equal('Test error');
    }
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Async Type Patterns

```typescript
// Promise.all with types
const promises: Promise<number>[] = [
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3)
];
const results: number[] = await Promise.all(promises);

// Promise.allSettled
const settled = await Promise.allSettled(promises);
settled.forEach(result => {
  if (result.status === 'fulfilled') {
    console.log(result.value); // number
  } else {
    console.log(result.reason); // any
  }
});

// Async generators
async function* asyncGenerator(): AsyncGenerator<number> {
  yield 1;
  yield 2;
  yield 3;
}

for await (const num of asyncGenerator()) {
  console.log(num); // number
}
```
</SlideLayout.Center>