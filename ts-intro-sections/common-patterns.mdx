import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Full>
## Common TypeScript Patterns: Readonly Properties

```
interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
}
```
</SlideLayout.Full>
<SlideLayout.Full>
## Common TypeScript Patterns: Index Signatures

```typescript
interface StringDictionary {
  [key: string]: string;
}
```
</SlideLayout.Full>
<SlideLayout.Full>
## Common TypeScript Patterns: Discriminated Unions

```typescript
type Shape = 
  | { kind: "circle"; radius: number }
  | { kind: "square"; size: number };
```
</SlideLayout.Full>

<SlideLayout.Center>
## Real World Example

```typescript
interface TodoItem {
  id: string;
  title: string;
  completed: boolean;
  createdAt: Date;
}

type TodoFilter = "all" | "active" | "completed";

function filterTodos(todos: TodoItem[], filter: TodoFilter): TodoItem[] {
  switch (filter) {
    case "active":
      return todos.filter(todo => !todo.completed);
    case "completed":
      return todos.filter(todo => todo.completed);
    default:
      return todos;
  }
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Build a State Machine

```typescript
// Create a type-safe state machine for a traffic light

// TODO: Define the states and transitions
type TrafficLightState = any; // Replace this
type TrafficLightEvent = any; // Replace this

class TrafficLight {
  private state: TrafficLightState = "red";
  
  transition(event: TrafficLightEvent): void {
    // TODO: Implement state transitions
    // Red -> Green (on "next")
    // Green -> Yellow (on "next")
    // Yellow -> Red (on "next")
    // Any state -> Red (on "emergency")
  }
  
  getState(): TrafficLightState {
    return this.state;
  }
}

// Usage
const light = new TrafficLight();
console.log(light.getState()); // "red"
light.transition("next");
console.log(light.getState()); // "green"
light.transition("emergency");
console.log(light.getState()); // "red"

// ***
describe('TrafficLight - Initial Implementation', () => {
  let testLight;
  
  before(() => {
    testLight = new TrafficLight();
  });
  
  it('should start at red state', () => {
    expect(testLight.getState()).to.equal("red");
  });
  
  it('should transition from red to green on next', () => {
    testLight.transition("next");
    expect(testLight.getState()).to.equal("green");
  });
});
// ---
// Step 1: Define states and events
type TrafficLightState = "red" | "yellow" | "green";
type TrafficLightEvent = "next" | "emergency";

class TrafficLight {
  private state: TrafficLightState = "red";
  
  transition(event: TrafficLightEvent): void {
    switch (this.state) {
      case "red":
        if (event === "next") this.state = "green";
        break;
      case "green":
        if (event === "next") this.state = "yellow";
        break;
      case "yellow":
        if (event === "next") this.state = "red";
        break;
    }
    
    // Emergency always goes to red
    if (event === "emergency") {
      this.state = "red";
    }
  }
  
  getState(): TrafficLightState {
    return this.state;
  }
}

// ***
describe('TrafficLight - Step 1: Full cycle', () => {
  let light;
  
  beforeEach(() => {
    light = new TrafficLight();
  });
  
  it('should complete full cycle: red -> green -> yellow -> red', () => {
    expect(light.getState()).to.equal("red");
    
    light.transition("next");
    expect(light.getState()).to.equal("green");
    
    light.transition("next");
    expect(light.getState()).to.equal("yellow");
    
    light.transition("next");
    expect(light.getState()).to.equal("red");
  });
  
  it('should handle emergency transition from any state', () => {
    light.transition("next"); // green
    expect(light.getState()).to.equal("green");
    
    light.transition("emergency");
    expect(light.getState()).to.equal("red");
  });
});
// ---
// Step 2: Type-safe state machine with transitions map
type TrafficLightState = "red" | "yellow" | "green";
type TrafficLightEvent = "next" | "emergency";

type StateTransitions = {
  [S in TrafficLightState]: {
    [E in TrafficLightEvent]?: TrafficLightState;
  };
};

const transitions: StateTransitions = {
  red: { next: "green", emergency: "red" },
  green: { next: "yellow", emergency: "red" },
  yellow: { next: "red", emergency: "red" }
};

class TrafficLight {
  private state: TrafficLightState = "red";
  
  transition(event: TrafficLightEvent): void {
    const nextState = transitions[this.state][event];
    if (nextState) {
      this.state = nextState;
    }
  }
  
  getState(): TrafficLightState {
    return this.state;
  }
  
  canTransition(event: TrafficLightEvent): boolean {
    return transitions[this.state][event] !== undefined;
  }
}

// ***
describe('TrafficLight - Step 2: Transition map', () => {
  let light2;
  
  beforeEach(() => {
    light2 = new TrafficLight();
  });
  
  it('should be able to check valid transitions', () => {
    expect(light2.canTransition("next")).to.be.true;
    expect(light2.canTransition("emergency")).to.be.true;
  });
  
  it('should ignore invalid transitions', () => {
    light2.transition("next"); // green
    light2.transition("emergency"); // red
    light2.transition("next"); // green
    
    const stateBefore = light2.getState();
    light2.transition("invalid" as any); // Should be ignored
    expect(light2.getState()).to.equal(stateBefore);
  });
});
// ---
// Step 3: Generic state machine
class StateMachine<State extends string, Event extends string> {
  constructor(
    private state: State,
    private transitions: Record<State, Partial<Record<Event, State>>>
  ) {}
  
  transition(event: Event): boolean {
    const nextState = this.transitions[this.state][event];
    if (nextState) {
      this.state = nextState as State;
      return true;
    }
    return false;
  }
  
  getState(): State {
    return this.state;
  }
  
  canTransition(event: Event): boolean {
    return this.transitions[this.state][event] !== undefined;
  }
}

// Now we can create any state machine!
type DoorState = "open" | "closed" | "locked";
type DoorEvent = "open" | "close" | "lock" | "unlock";

const doorMachine = new StateMachine<DoorState, DoorEvent>("closed", {
  open: { close: "closed" },
  closed: { open: "open", lock: "locked" },
  locked: { unlock: "closed" }
});

// ***
describe('StateMachine - Step 3: Generic implementation', () => {
  it('should work with door state machine', () => {
    doorMachine.transition("open");
    expect(doorMachine.getState()).to.equal("open");
    
    doorMachine.transition("close");
    expect(doorMachine.getState()).to.equal("closed");
    
    doorMachine.transition("lock");
    expect(doorMachine.getState()).to.equal("locked");
    
    expect(doorMachine.canTransition("open")).to.be.false;
  });
});
```
</SlideLayout.Center>