import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## React with TypeScript

- Type-safe components and props
- Event handling with proper types
- Hooks with TypeScript
- Generic components

```typescript
// Basic functional component
interface ButtonProps {
  text: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({ 
  text, 
  onClick, 
  variant = 'primary',
  disabled = false 
}) => {
  return (
    <button 
      className={`btn btn-${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {text}
    </button>
  );
};
```
</SlideLayout.Center>

<SlideLayout.Center>
## Event Handling

```typescript
// Properly typed event handlers
interface FormProps {
  onSubmit: (data: FormData) => void;
}

interface FormData {
  username: string;
  email: string;
}

const LoginForm: React.FC<FormProps> = ({ onSubmit }) => {
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    onSubmit({
      username: formData.get('username') as string,
      email: formData.get('email') as string
    });
  };
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    console.log(e.target.value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="username" onChange={handleChange} />
      <input name="email" type="email" onChange={handleChange} />
      <button type="submit">Submit</button>
    </form>
  );
};
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Build a Type-Safe Todo Component

```typescript
// Test setup
let logSpy: sinon.SinonSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

// ***
// Create a type-safe Todo list component

interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

interface TodoListProps {
  todos: Todo[];
  onToggle: (id: string) => void;
  onDelete: (id: string) => void;
}

// TODO: Implement this component
const TodoList: React.FC<TodoListProps> = ({ todos, onToggle, onDelete }) => {
  return (
    <div>
      {/* Implement the todo list */}
    </div>
  );
};

// TODO: Implement this component
const TodoItem: React.FC<{ todo: Todo; onToggle: () => void; onDelete: () => void }> = ({
  todo,
  onToggle,
  onDelete
}) => {
  return (
    <div>
      {/* Implement the todo item */}
    </div>
  );
};

// Usage
const todos: Todo[] = [
  { id: '1', text: 'Learn TypeScript', completed: false },
  { id: '2', text: 'Build React app', completed: true }
];

const handleToggle = (id: string) => console.log('Toggle:', id);
const handleDelete = (id: string) => console.log('Delete:', id);

// Simulate rendering
console.log('Rendering TodoList with', todos.length, 'todos');

// ***
describe('Todo Components', () => {
  it('should have correct todo structure', () => {
    expect(todos).to.have.lengthOf(2);
    expect(todos[0]).to.have.property('id');
    expect(todos[0]).to.have.property('text');
    expect(todos[0]).to.have.property('completed');
  });
  
  it('should log rendering info', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args).to.include('Rendering TodoList with');
    expect(logSpy.firstCall.args).to.include(2);
  });
});
// ---
// Test setup (reuse)
let logSpy: sinon.SinonSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

// ***
// Step 1: Implement the components
interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

interface TodoListProps {
  todos: Todo[];
  onToggle: (id: string) => void;
  onDelete: (id: string) => void;
}

const TodoItem: React.FC<{ 
  todo: Todo; 
  onToggle: () => void; 
  onDelete: () => void 
}> = ({ todo, onToggle, onDelete }) => {
  return (
    <div className="todo-item">
      <input 
        type="checkbox" 
        checked={todo.completed} 
        onChange={onToggle}
      />
      <span 
        style={{ 
          textDecoration: todo.completed ? 'line-through' : 'none' 
        }}
      >
        {todo.text}
      </span>
      <button onClick={onDelete}>Delete</button>
    </div>
  );
};

const TodoList: React.FC<TodoListProps> = ({ todos, onToggle, onDelete }) => {
  return (
    <div className="todo-list">
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={() => onToggle(todo.id)}
          onDelete={() => onDelete(todo.id)}
        />
      ))}
      {todos.length === 0 && <p>No todos yet!</p>}
    </div>
  );
};

// Test the components
const todos: Todo[] = [
  { id: '1', text: 'Learn TypeScript', completed: false },
  { id: '2', text: 'Build React app', completed: true }
];

const handleToggle = (id: string) => console.log('Toggle:', id);
const handleDelete = (id: string) => console.log('Delete:', id);

// Simulate component behavior
console.log('Rendering TodoList with', todos.length, 'todos');
todos.forEach(todo => {
  console.log(`- ${todo.text} (${todo.completed ? 'done' : 'pending'})`);
});

// Simulate interactions
handleToggle('1');
handleDelete('2');

// ***
describe('Todo Components Implementation', () => {
  it('should render todos with correct info', () => {
    expect(logSpy.callCount).to.be.at.least(3);
    expect(logSpy.getCall(0).args).to.include('Rendering TodoList with');
  });
  
  it('should display todo status correctly', () => {
    const todoLogs = logSpy.getCalls().filter(call => 
      call.args[0] && call.args[0].includes('-')
    );
    expect(todoLogs).to.have.lengthOf(2);
    expect(todoLogs[0].args[0]).to.include('pending');
    expect(todoLogs[1].args[0]).to.include('done');
  });
  
  it('should handle toggle and delete', () => {
    const toggleLog = logSpy.getCalls().find(call => 
      call.args[0] === 'Toggle:'
    );
    const deleteLog = logSpy.getCalls().find(call => 
      call.args[0] === 'Delete:'
    );
    
    expect(toggleLog.args[1]).to.equal('1');
    expect(deleteLog.args[1]).to.equal('2');
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Hooks with TypeScript

```typescript
// useState with type inference
const [count, setCount] = useState(0); // number inferred
const [name, setName] = useState(''); // string inferred

// useState with explicit types
const [user, setUser] = useState<User | null>(null);

// useReducer with types
type Action = 
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset'; payload: number };

const reducer = (state: number, action: Action): number => {
  switch (action.type) {
    case 'increment': return state + 1;
    case 'decrement': return state - 1;
    case 'reset': return action.payload;
  }
};

const [state, dispatch] = useReducer(reducer, 0);

// Custom hooks
function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });
  
  const setStoredValue = (value: T) => {
    setValue(value);
    localStorage.setItem(key, JSON.stringify(value));
  };
  
  return [value, setStoredValue] as const;
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Generic Components

```typescript
// Generic list component
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <ul>
      {items.map(item => (
        <li key={keyExtractor(item)}>
          {renderItem(item)}
        </li>
      ))}
    </ul>
  );
}

// Usage with different types
const users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
const numbers = [1, 2, 3, 4, 5];

<List 
  items={users}
  renderItem={user => <span>{user.name}</span>}
  keyExtractor={user => user.id.toString()}
/>

<List
  items={numbers}
  renderItem={num => <span>{num * 2}</span>}
  keyExtractor={num => num.toString()}
/>
```
</SlideLayout.Center>