import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.HorizontalImage title="Intro to TypeScript" src="https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExNXpqdm9hNHB2aHc2MnNhZm5hYXBlc2oxaG82NzhuYWNwYmtkNG84OSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/pzmbXFDiRbEEk1vCtP/giphy.gif" />

<SlideLayout.Center>
  ## What is TypeScript
  - TypeScript is an extension of the JavaScript language
  - It adds annotations that describe what "type" we expect values to be
  - The TypeScript compiler checks these annotations and ensures they match
  - It also removes them during compilation to output pure JavaScript
</SlideLayout.Center>

<SlideLayout.Center>
## What's a Type?

- Types are shapes: a set of properties and methods we expect values to implement
- Strings, Numbers, Objects...even `undefined` and `null` values all have corresponding types
- In JavaScript, references to values in variables, arguments, and return types can be anything
- TypeScript defines what shapes each value should be, and checks that we keep that contract
</SlideLayout.Center>

<SlideLayout.Full>
## JavaScript is an Enigma
<FlexBox alignItems="center" justifyContent="center" flexDirection="column">
  <video autoPlay style={{
    height: 'calc(80vh / (1920 / 1080))',
  }} muted data-autoplay src="https://ctp-presentation-media.s3.us-east-2.amazonaws.com/javascript-toy.mp4
">
  </video>
</FlexBox>
</SlideLayout.Full>

https://ctp-presentation-media.s3.us-east-2.amazonaws.com/javascript-toy.mp4
<SlideLayout.Full>
## TypeScript is a Cool Toy
<FlexBox alignItems="center" justifyContent="center" flexDirection="column">
  <video autoPlay style={{
    height: 'calc(80vh / (1920 / 1080))',
  }} muted data-autoplay src="https://ctp-presentation-media.s3.us-east-2.amazonaws.com/playskool-shape-toy.mp4">
  </video>
</FlexBox>
</SlideLayout.Full>

<SlideLayout.Center>
## JavaScript's Type Problem

<FlexBox alignItems="center" justifyContent="center" flexDirection="column">

What's wrong with this picture?

```javascript
function calculateDiscount(price, discount) {
  return price - (price * discount);
}

console.log(calculateDiscount(100, "20%")); // Oops!
// ---
function calculateDiscount(price, discount) {
  return price - (price * discount);
}

console.log(calculateDiscount(100, 0.2));
```
</FlexBox>
</SlideLayout.Center>

<SlideLayout.VerticalImage
  title="The Price is NaN, Bob"
  src="https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExOHAxempuYnNlc29zbnQ0NHBmd2lwdjhjdnpqYnZwdGhmZ2NjeXJieCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/fpFPWzrXhLOo6uFXGg/giphy.gif"
  listItems={[
    'In JavaScript, we can pass any value to a function',
    'JavaScript will try to do the non-sensical math',
    'This results in `NaN` (Not a Number)',
    'This bug that can be hard to find',
  ]}
/>

<SlideLayout.Center>
## TypeScript can predict the future

- On the other hand, TypeScript can tell us about this mistake beforehand
- If we say its a number, TypeScript will complain if we try to give a string
- These bugs happen all the time in JavaScript, as we pass values around
</SlideLayout.Center>

<SlideLayout.Center>
## With TypeScript...

```typescript
function calculateDiscount(price: number, discount: number): number {
  return price - (price * discount);
}

console.log(calculateDiscount(100, "20%"));
// ---
function calculateDiscount(price: number, discount: number): number {
  return price - (price * discount);
}

console.log(calculateDiscount(100, "20%"));
```
</SlideLayout.Center>

<SlideLayout.Center>
## A Silver Bullet in a Foot Gun

- TypeScript guarantees the values ***you assign*** will be of the expected type
- However, values ***you don't assign***, like those that come from API's and users may be incorrect
- Understanding this loophole is important to knowing where to validate, or check data
</SlideLayout.Center>

<SlideLayout.Center>
## The Type Layer
- TypeScript is really two languages in one file
- There's JavaScript, this describes what does happen at runtime
- There's TypeScript, this annotates the JavaScript, describes what should happen at runtime
</SlideLayout.Center>

<SlideLayout.Full>
## JavaScript vs. TypeScript
```typescript
// JavaScript
function calculateDiscount(price, discount) {
  return price - (price * discount);
}

console.log(calculateDiscount(100, "20%"));
// ---
// TypeScript
function calculateDiscount(price: number, discount: number): number {
  return price - (price * discount);
}

console.log(calculateDiscount(100, "20%"));
```
</SlideLayout.Full>

<SlideLayout.Center>
## The Power of Intellisense

- TypeScript tells us about values as we type
- As you're typing `'20%'`, VSCode will give you the error inline
- TypeScript gives your editor additional super-powers, like:
  - Finding all references to a value
  - Seeing what properties an object has
  - Renaming a property across the entire codebase
</SlideLayout.Center>

<SlideLayout.Full>
## Intellisense in Action
```typescript
type User = {
  /** The name of the user, duh */
  name: string;
  /** How old they be */
  age: number;
  /** Are they the creator of the multiverse? */
  isAdmin: boolean;
}

const user: User = {
  name: "Ryan",
  age: 30,
  isAdmin: false,
};
```

</SlideLayout.Full>

<SlideLayout.Full>
## TypeScript's Type System
  <FlexBox alignItems="center" justifyContent="center" flexDirection="row">
    <Box width="100%" height="100%">
      - `undefined`
      - `null`
      - `boolean`
      - `number`
      - `bigint`
      - `string`
      - `symbol`
    </Box>
    <Box width="100%" height="100%">
      - `object`
      - `Function`
      - `Array`
      - `Tuple`
      - `any`
      - `unknown`
      - `never`
    </Box>
  </FlexBox>
</SlideLayout.Full>
<SlideLayout.Full>
## TypeScript's Type System In Action
```typescript
let undef: undefined
let nil = null
let bool = true
let num = 42
let big = 9007199254740991n
let str = "Hello, TypeScript!"
let sym = Symbol("unique")
let obj = { key: "value" }
let func = () => console.log("Hello, Function!")
let arr = [1, 2, 3]
let tuple = ["TypeScript", 4] as [string, number]
let anyValue = "Can be anything" as any
let unknownValue = "Could be anything, but we don't know yet" as unknown
let neverValue = (() => { throw new Error("This should never happen") })()
```
</SlideLayout.Full>

<SlideLayout.Center>
## Type Inference

- TypeScript is smart enough to figure out types on its own
- You don't always need to explicitly write types
- TypeScript will infer types from the values you assign
- This makes TypeScript feel more like JavaScript

```typescript
// TypeScript knows this is a string
let message = "Hello, TypeScript!";

// TypeScript knows this returns a number
function add(a: number, b: number) {
  return a + b;
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Union Types

- Sometimes a value can be one of several types
- Union types use the `|` operator to say "this OR that"
- Common in real-world scenarios

```typescript
type Status = "loading" | "success" | "error";

function setStatus(status: Status) {
  console.log(`Current status: ${status}`);
}

setStatus("loading"); // ✅
setStatus("pending"); // ❌ Error!
```
</SlideLayout.Center>

<SlideLayout.VerticalImage
  title="Interfaces vs Types"
  src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExaGo5NnJmMmt2dGp6cWNqeHF5Y3BwNnl0YjNkY2x3c3ZyZWRmMnFnZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3o7btPCcdNniyf0ArS/giphy.gif"
  listItems={[
    'Interfaces define object shapes',
    'Types can define any type (objects, unions, primitives)',
    'Interfaces can be extended and merged',
    'Types are more flexible but cannot be reopened',
  ]}
/>

<SlideLayout.Full>
## Interface Example

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

interface Admin extends User {
  permissions: string[];
}

const admin: Admin = {
  id: 1,
  name: "Alice",
  email: "alice@example.com",
  permissions: ["read", "write", "delete"]
};
```
</SlideLayout.Full>

<SlideLayout.Center>
## Optional Properties

- Not all properties are required all the time
- Use `?` to make a property optional
- TypeScript will allow the property to be missing

```typescript
interface UserProfile {
  name: string;
  bio?: string;  // Optional
  avatar?: string;  // Optional
}

const user1: UserProfile = { name: "Bob" }; // ✅
const user2: UserProfile = { 
  name: "Alice", 
  bio: "TypeScript enthusiast" 
}; // ✅
```
</SlideLayout.Center>

<SlideLayout.Center>
## Arrays and Generics

- Arrays can be typed in two ways
- Generics allow types to be flexible but safe
- Think of generics as "type functions" with argument types and a return type

```typescript
// Two ways to type arrays
let numbers: number[] = [1, 2, 3];
let strings: Array<string> = ["a", "b", "c"];

// Generic function
function identity<T>(value: T): T {
  return value;
}

identity<string>("hello"); // Returns string
identity<number>(42); // Returns number
```
</SlideLayout.Center>

<SlideLayout.VerticalImage
  title="Type Guards"
  src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbXVwYWFiM2ZneWo0Y3B3MmVmeGZ1aDZ2c3FuMWVrczNsb2I0YnJhbyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3ohzdQ1IynzclJldUQ/giphy.gif"
  listItems={[
    'Type guards help narrow down union types',
    'Common guards: typeof, instanceof, in',
    'Custom type guards with "is" keyword',
    'Essential for working with unions safely',
  ]}
/>

<SlideLayout.Full>
## Type Guards in Action

```typescript
type Result = 
  | { success: true; data: string }
  | { success: false; error: string };

function handleResult(result: Result) {
  if (result.success) {
    // TypeScript knows result.data exists here
    console.log("Success:", result.data);
  } else {
    // TypeScript knows result.error exists here
    console.log("Error:", result.error);
  }
}
```
</SlideLayout.Full>

<SlideLayout.Center>
## Async/Await Types

- Promises and async functions have special types
- TypeScript tracks what a Promise resolves to
- Helps catch async errors at compile time

```typescript
async function fetchUser(id: number): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// TypeScript knows user is of type User
const user = await fetchUser(1);
console.log(user.name); // ✅
console.log(user.invalid); // ❌ Error!
```
</SlideLayout.Center>

<SlideLayout.Full>
## Common TypeScript Patterns: Readonly Properties

```
interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
}
```
</SlideLayout.Full>
<SlideLayout.Full>
## Common TypeScript Patterns: Index Signatures

```typescript
interface StringDictionary {
  [key: string]: string;
}
```
</SlideLayout.Full>
<SlideLayout.Full>
## Common TypeScript Patterns: Discriminated Unions

```typescript
type Shape = 
  | { kind: "circle"; radius: number }
  | { kind: "square"; size: number };
```
</SlideLayout.Full>

<SlideLayout.VerticalImage
  title="TypeScript Best Practices"
  src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExZnVhdm9wOHRibHNmcDdqcDRxaWg4M2I0M3J2c3cwcGprM3JyM3czNCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/26tn33aiTi1jkl6H6/giphy.gif"
  listItems={[
    'Start with strict mode enabled',
    'Let TypeScript infer when possible',
    'Use union types instead of any',
    'Define types for external data',
    'Use const assertions for literals',
  ]}
/>

<SlideLayout.Center>
## Real World Example

```typescript
interface TodoItem {
  id: string;
  title: string;
  completed: boolean;
  createdAt: Date;
}

type TodoFilter = "all" | "active" | "completed";

function filterTodos(todos: TodoItem[], filter: TodoFilter): TodoItem[] {
  switch (filter) {
    case "active":
      return todos.filter(todo => !todo.completed);
    case "completed":
      return todos.filter(todo => todo.completed);
    default:
      return todos;
  }
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## TypeScript Ecosystem

- **tsc**: The TypeScript compiler
- **tsconfig.json**: Configuration file for TypeScript projects
- **@types**: Community type definitions for JavaScript libraries
- **ts-node**: Run TypeScript directly without compiling
- **ESLint**: Linting for TypeScript code

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true
  }
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Common Gotchas

1. **Type vs Runtime**: Types don't exist at runtime
2. **Type Assertions**: Use sparingly, they bypass checks
3. **any**: The escape hatch that defeats the purpose
4. **Structural Typing**: TypeScript cares about shape, not names

```typescript
// This works because shapes match!
interface Point { x: number; y: number; }
interface Coordinate { x: number; y: number; }

let point: Point = { x: 1, y: 2 };
let coord: Coordinate = point; // ✅ No error!
```
</SlideLayout.Center>

<SlideLayout.HorizontalImage 
  title="Thank You!"
  src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExcHN5NWg2MjJ1MWN6MXBwdnBveWVlNzBwdGRhYjh3YWt2OHR6ZnE3ZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3oz8xIsloV7zOmt81G/giphy.gif"
/>

