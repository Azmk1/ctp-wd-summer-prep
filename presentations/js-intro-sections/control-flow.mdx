import { SlideLayout, Image, FlexBox, Box} from 'spectacle'
import { CodeDisplay, File, Version, Tests } from '../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## Control Flow

Making decisions and repeating tasks in JavaScript
</SlideLayout.Full>

<SlideLayout.Full>
## Understanding Decision Making in Code

Programs need to make decisions based on data:

- Execute different code based on conditions
- Use comparison operators: `===`, `!==`, `>`, `<`, `>=`, `<=`
- Combine conditions with `&&` (and), `||` (or), `!` (not)

**The Goal**: Build logic that responds to different situations
</SlideLayout.Full>

<SlideLayout.Full>
## Conditional Statements

**if/else** - Basic decision making:
```javascript
if (condition) {
  // code if true
} else {
  // code if false
}
```
</SlideLayout.Full>
<SlideLayout.Full>
## Conditional Statements
**Switch** - Multiple options:
```javascript
switch (value) {
  case option1:
    // code
    break;
  case option2:
    // code
    break;
  default:
    // default code
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## if/else Chains

For multiple conditions:
```javascript
if (score >= 90) {
  grade = "A";
} else if (score >= 80) {
  grade = "B";
} else if (score >= 70) {
  grade = "C";
} else {
  grade = "F";
}
```

- Check conditions in order
- First true condition wins
- else catches everything else
</SlideLayout.Full>

<SlideLayout.Full>
## Ternary Operator

For simple conditions:
```javascript
const status = isLoggedIn ? "Welcome!" : "Please log in";

// Same as:
let status;
if (isLoggedIn) {
  status = "Welcome!";
} else {
  status = "Please log in";
}
```

- Concise conditional assignment
- Best for simple true/false cases
- Can be nested (but avoid complexity)
</SlideLayout.Full>

<SlideLayout.Full>
## Switch Statements

For many discrete options:
```javascript
switch (day) {
  case "Monday": 
    return "Start of work week";
  case "Friday": 
    return "TGIF!";
  case "Saturday":
  case "Sunday":
    return "Weekend!";
  default: 
    return "Regular day";
}
```

- Cleaner than multiple if/else
- Don't forget `break` statements!
- Can group cases together
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise Overview: Habit Streak Messages

You'll build conditional logic for a habit tracker that:

1. **Analyzes streak length** and shows encouraging messages
2. **Categorizes habits** with appropriate icons/styling  
3. **Checks activity status** to show current state

</SlideLayout.Full>
<SlideLayout.Full>
## Exercise Overview: Habit Streak Messages

**Key Concepts to Apply:**
- if/else chains for streak milestones
- Switch statement for category handling
- Ternary operator for active/inactive status
</SlideLayout.Full>

<SlideLayout.Full>
## Control Flow Exercise

<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Create control flow for habit streak messages
// TODO: Write code that:
// 1. Displays different messages based on streak length:
//    - 30+ days: "Habit Master!"
//    - 7+ days: "On fire!"
//    - 3+ days: "Getting consistent!"
//    - Otherwise: "Keep going!"
// 2. Shows "Active" or "Inactive" status
// 3. Categorizes habits (health/productivity/learning)

const currentStreak = 7;
const habitCategory = "health";
const isActive = true;

// Your code here...
```
    
    
```javascript
// Solution: Using if/else statements
const currentStreak = 7;
const habitCategory = "health";
const isActive = true;

// 1. Streak messages
let streakMessage;
if (currentStreak >= 30) {
  streakMessage = "Habit Master!";
} else if (currentStreak >= 7) {
  streakMessage = "On fire!";
} else if (currentStreak >= 3) {
  streakMessage = "Getting consistent!";
} else {
  streakMessage = "Keep going!";
}

// 2. Activity status
const status = isActive ? "Active" : "Inactive";

// 3. Category handling
let categoryIcon;
switch (habitCategory) {
  case "health":
    categoryIcon = "💪";
    break;
  case "productivity":
    categoryIcon = "⚡";
    break;
  case "learning":
    categoryIcon = "📚";
    break;
  default:
    categoryIcon = "📋";
}

console.log(`${categoryIcon} Status: ${status}`);
console.log(`Streak: ${currentStreak} days - ${streakMessage}`);
```
    
  </File>
  <Tests>
    
```javascript
// Tests for Control Flow
describe('Habit Streak Messages', () => {
  it('should display correct streak message for 30+ days', () => {
    const streak = 30;
    let message;
    if (streak >= 30) {
      message = "Habit Master!";
    } else if (streak >= 7) {
      message = "On fire!";
    } else if (streak >= 3) {
      message = "Getting consistent!";
    } else {
      message = "Keep going!";
    }
    expect(message).to.equal("Habit Master!");
  });
  
  it('should display correct streak message for 7+ days', () => {
    expect(streakMessage).to.equal("On fire!");
  });
  
  it('should show active status', () => {
    expect(status).to.equal("Active");
  });
  
  it('should categorize health habits correctly', () => {
    expect(categoryIcon).to.equal("💪");
  });
});
```
    
  </Tests>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Understanding Iteration

When you have collections of data, you need to process each item:

**Different Loop Types:**
- **for loop** - when you need index/counter control
- **for...of loop** - when you want to iterate over values  
- **while loop** - when you don't know how many iterations needed
- **Array methods** - functional programming approach
</SlideLayout.Full>

<SlideLayout.Full>
## Common Data Processing Tasks

With loops, you can:
- Count items that meet criteria
- Calculate totals/averages
- Find maximum/minimum values
- Transform data into new formats
- Filter collections based on conditions

Let's explore each loop type...
</SlideLayout.Full>

<SlideLayout.Full>
## Traditional for Loop

When you need index control:
```javascript
for (let i = 0; i < array.length; i++) {
  console.log(i, array[i]); // Access index and value
}

// Count backwards
for (let i = array.length - 1; i >= 0; i--) {
  console.log(array[i]);
}

// Skip every other item
for (let i = 0; i < array.length; i += 2) {
  console.log(array[i]);
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## for...of Loop

When you just need values:
```javascript
const habits = ["Exercise", "Read", "Meditate"];

for (const habit of habits) {
  console.log(habit); // Direct access to value
}

// Works with strings too
for (const char of "Hello") {
  console.log(char); // H, e, l, l, o
}
```

Cleaner syntax when index isn't needed
</SlideLayout.Full>

<SlideLayout.Full>
## while Loop

When iteration count is unknown:
```javascript
while (condition) {
  // code
  // update condition
}

// Example: Find first habit with 30+ streak
let index = 0;
while (index < habits.length && habits[index].streak < 30) {
  index++;
}
```

Be careful of infinite loops!
</SlideLayout.Full>

<SlideLayout.Full>
## Loop Patterns: Counting and Accumulating

```javascript
// Count items meeting criteria
let count = 0;
for (const item of items) {
  if (item.completed) {
    count++;
  }
}

// Calculate total
let total = 0;
for (const item of items) {
  total += item.points;
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## Loop Patterns: Finding Extremes

```javascript
// Find maximum value
let maxValue = 0;
let bestItem = null;

for (const item of items) {
  if (item.value > maxValue) {
    maxValue = item.value;
    bestItem = item;
  }
}

// Find first matching item
let found = null;
for (const item of items) {
  if (item.name === searchName) {
    found = item;
    break; // Exit early
  }
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## Loop Patterns: Building Collections

```javascript
// Filter items
const results = [];
for (const item of items) {
  if (item.isActive) {
    results.push(item);
  }
}

// Transform items
const names = [];
for (const item of items) {
  names.push(item.name.toUpperCase());
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise Overview: Weekly Habit Analysis

You'll process a week's worth of habit data to:

1. **Count completions** across the week
2. **Calculate total points** earned  
3. **Find the best day** with highest points
4. **List completed days** for reporting

You'll practice different loop techniques for each task!
</SlideLayout.Full>

<SlideLayout.Full>
## Loops and Iteration Exercise

<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Process weekly habit data
// TODO: Use loops to:
// 1. Count how many days were completed
// 2. Calculate total points earned
// 3. Find the best day (highest points)
// 4. List all completed days

const weeklyHabits = [
  { day: "Mon", completed: true, points: 10 },
  { day: "Tue", completed: true, points: 15 },
  { day: "Wed", completed: false, points: 0 },
  { day: "Thu", completed: true, points: 10 },
  { day: "Fri", completed: true, points: 20 },
  { day: "Sat", completed: true, points: 15 },
  { day: "Sun", completed: false, points: 0 }
];

// Your code here...
```
    
    
```javascript
// Solution: Using different loop types
const weeklyHabits = [
  { day: "Mon", completed: true, points: 10 },
  { day: "Tue", completed: true, points: 15 },
  { day: "Wed", completed: false, points: 0 },
  { day: "Thu", completed: true, points: 10 },
  { day: "Fri", completed: true, points: 20 },
  { day: "Sat", completed: true, points: 15 },
  { day: "Sun", completed: false, points: 0 }
];

// 1. Count completed days (for loop)
let completedCount = 0;
for (let i = 0; i < weeklyHabits.length; i++) {
  if (weeklyHabits[i].completed) {
    completedCount++;
  }
}

// 2. Calculate total points (for...of loop)
let totalPoints = 0;
for (const day of weeklyHabits) {
  if (day.completed) {
    totalPoints += day.points;
  }
}

// 3. Find best day (while loop)
let bestDay = null;
let highestPoints = 0;
let index = 0;
while (index < weeklyHabits.length) {
  const day = weeklyHabits[index];
  if (day.completed && day.points > highestPoints) {
    highestPoints = day.points;
    bestDay = day.day;
  }
  index++;
}

// 4. List completed days (array methods)
const completedDays = weeklyHabits
  .filter(day => day.completed)
  .map(day => day.day);

console.log(`Completed ${completedCount} days`);
console.log(`Total points: ${totalPoints}`);
console.log(`Best day: ${bestDay} (${highestPoints} points)`);
console.log(`Completed days: ${completedDays.join(', ')}`);
```
    
  </File>
  <Tests>
    
```javascript
// Tests for Loops and Iteration
describe('Weekly Habit Processing', () => {
  it('should count completed days correctly', () => {
    expect(completedCount).to.equal(5);
  });
  
  it('should calculate total points correctly', () => {
    expect(totalPoints).to.equal(70);
  });
  
  it('should find the best day', () => {
    expect(bestDay).to.equal("Fri");
    expect(highestPoints).to.equal(20);
  });
  
  it('should list all completed days', () => {
    expect(completedDays).to.deep.equal(["Mon", "Tue", "Thu", "Fri", "Sat"]);
  });
});
```
    
  </Tests>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Common Pitfall: Missing break

```javascript
// ❌ Wrong - falls through!
switch (habitCategory) {
  case "health":
    icon = "💪";
    // Missing break!
  case "learning":
    icon = "📚"; // This always runs!
}

// ✅ Correct
switch (habitCategory) {
  case "health":
    icon = "💪";
    break;
  case "learning":
    icon = "📚";
    break;
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## Common Pitfall: Off-by-One Errors

```javascript
// ❌ Wrong - misses last element
for (let i = 0; i < array.length - 1; i++) { 
  console.log(array[i]);
}

// ✅ Correct
for (let i = 0; i < array.length; i++) { 
  console.log(array[i]);
}

// ❌ Wrong - goes past array end
for (let i = 0; i <= array.length; i++) { 
  console.log(array[i]); // undefined on last iteration
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## Common Pitfall: Truthy/Falsy Confusion

```javascript
// ❌ Fails when streak is 0
if (habit.streak) { 
  console.log("Has streak");
}

// ✅ Better - explicit check
if (habit.streak !== undefined) { 
  console.log("Has streak value");
}

// ✅ Or check for specific condition
if (habit.streak > 0) { 
  console.log("Has positive streak");
}
```

Remember: 0, "", null, undefined, false are all falsy!
</SlideLayout.Full>

<SlideLayout.Full>
## Loop Performance: Cache Array Length

```javascript
// ❌ Slower - calculates length each iteration
for (let i = 0; i < habits.length; i++) { 
  // habits.length is evaluated every loop
}

// ✅ Faster - cache length once
const len = habits.length;
for (let i = 0; i < len; i++) { 
  // len is just a variable lookup
}
```

Most important for very large arrays
</SlideLayout.Full>

<SlideLayout.Full>
## Loop Performance: Choose the Right Method

```javascript
// Simple iteration
for (const habit of habits) { 
  console.log(habit);
}

// When you need index
for (let i = 0; i < habits.length; i++) { 
  console.log(i, habits[i]);
}

// For transformation (functional)
const names = habits.map(h => h.name);

// For filtering (functional)
const active = habits.filter(h => h.isActive);
```
</SlideLayout.Full>

<SlideLayout.Full>
## Loop Performance: Break Early

```javascript
// ❌ Checks every item
let found = null;
for (const habit of habits) {
  if (habit.name === searchName) {
    found = habit;
  }
}

// ✅ Exits as soon as found
for (const habit of habits) {
  if (habit.name === searchName) {
    found = habit;
    break; // Stop searching!
  }
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## 🎯 Key Takeaways: Control Flow

1. **if/else** for simple decisions, **switch** for multiple options
2. **Ternary operator** for concise conditional assignments
3. **for loops** for index control, **for...of** for values
4. **while loops** for unknown iteration counts
5. **Array methods** provide functional alternatives to loops

### Bridge to Objects & Arrays
You can make decisions and repeat tasks. Now let's learn about the **data structures** that make JavaScript powerful!
</SlideLayout.Full>