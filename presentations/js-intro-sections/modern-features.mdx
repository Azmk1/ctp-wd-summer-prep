import { SlideLayout, Image, FlexBox, Box, Text} from 'spectacle'

<SlideLayout.Full>
## ðŸš€ Modern JavaScript Features
### ES6+ Features That Power Today's JavaScript

- Destructuring and spread syntax
- Template literals and tagged templates
- Optional chaining and nullish coalescing
- Modern array and object methods
- Async patterns and promises
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Why Modern JavaScript?
    - Cleaner, more expressive syntax
    - Better error handling and safety
    - Improved performance optimizations
    - Enhanced developer productivity
    
**The Evolution:**
- ES5 (2009) â†’ ES6/ES2015 â†’ Annual releases
- Each version adds powerful new features
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## Destructuring: Unpack Values Elegantly
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Object destructuring
const habit = {
  name: 'Exercise',
  category: 'health',
  streak: 5,
  points: 150
};

const { name, streak } = habit;
console.log(`${name}: ${streak} days`);

// Array destructuring
const [first, second, ...rest] = habits;

// Function parameter destructuring
function displayHabit({ name, category, streak = 0 }) {
  return `${name} (${category}): ${streak} days`;
}

// Nested destructuring
const { user: { preferences: { theme } } } = data;
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Spread and Rest Operators
**Spread (...) - Expand**
- Arrays: [...array1, ...array2]
- Objects: {...obj1, ...obj2}
- Function calls: fn(...args)

**Rest (...) - Collect**
- Function parameters: (...args)
- Destructuring: [first, ...rest]
- Flexible function signatures
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## Destructuring Benefits

**Extract exactly what you need:**
- Extract only the data you need
- Rename properties during extraction
- Provide default values for missing data
- Works in function parameters for cleaner APIs

```javascript
// Object destructuring with defaults and renaming
const { name, streak = 0, isActive: active } = habit;

// Array destructuring
const [first, second, ...rest] = habits;

// Function parameter destructuring
function displayHabit({ name, category, streak = 0 }) {
  return `${name} (${category}): ${streak} days`;
}

// Nested destructuring
const { user: { preferences: { theme } } } = appData;
```
</SlideLayout.Full>

<SlideLayout.Full>
## Spread/Rest Operator Benefits

**Flexible data manipulation:**
- Immutable updates: `{...obj, newProp: value}`
- Array combining: `[...arr1, ...arr2]`
- Function flexibility: `function fn(...args)`
- Clean object copying without mutation

```javascript
// Object spread for immutable updates
const updatedHabit = { ...habit, streak: habit.streak + 1 };

// Array spread for combining
const allHabits = [...healthHabits, ...learningHabits];

// Rest parameters for flexible functions
function logHabits(first, ...others) {
  console.log('Primary habit:', first);
  console.log('Other habits:', others);
}

// Spread in function calls
const points = [10, 20, 15];
const max = Math.max(...points); // instead of Math.max.apply()
```
</SlideLayout.Full>

<SlideLayout.Full>
## Modern Array and Object Methods

**Powerful built-in methods:**
- `flatMap()` - map and flatten in one step
- `Object.entries()` - convert object to [key, value] pairs
- `Object.fromEntries()` - convert pairs back to object

```javascript
// flatMap - map and flatten
const habitsByCategory = [
  ['exercise', 'reading'],
  ['meditation', 'journaling']
];
const allHabits = habitsByCategory.flatMap(habits => habits);
// ['exercise', 'reading', 'meditation', 'journaling']

// Object.entries and Object.fromEntries
const scores = { exercise: 10, reading: 8, meditation: 12 };
const doubled = Object.fromEntries(
  Object.entries(scores).map(([habit, score]) => [habit, score * 2])
);
// { exercise: 20, reading: 16, meditation: 24 }
```
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise Overview: Modern Habit Analytics

You'll build analytics functions using modern JavaScript features:

1. **mergeHabits()** - Combine habit objects using spread syntax
2. **getTopHabits()** - Extract top performers using modern array methods
3. **calculateStats()** - Use destructuring and reduce for aggregation
4. **transformHabitData()** - Reshape data with destructuring and object shorthand

**Modern Features You'll Apply:**
- Destructuring in function parameters
- Spread operator for object/array operations  
- Template literals for string formatting
- Modern array methods (filter, map, reduce, sort)
- Optional chaining for safe property access

**Goal**: Write cleaner, more expressive code using ES6+ features
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Modern Habit Analytics
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Use modern JS features to build habit analytics
// TODO: Implement functions using destructuring, spread, and modern methods

const habitData = [
  { id: 1, name: 'Exercise', category: 'health', completions: [1, 2, 3, 5, 6, 7], points: 150 },
  { id: 2, name: 'Reading', category: 'learning', completions: [1, 2, 4, 5], points: 80 },
  { id: 3, name: 'Meditation', category: 'wellness', completions: [2, 3, 4, 5, 6], points: 100 }
];

// TODO: 
// 1. mergeHabits(...habits) - merge multiple habit objects
// 2. getTopHabits(habits, n = 3) - get top n habits by points
// 3. calculateStats(habits) - return stats object with totals
// 4. transformHabitData(habits) - transform to new format

// Your implementation here...
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Template Literals: Beyond String Concatenation
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Multi-line strings
const habitReport = `
  Habit Performance Report
  =======================
  Name: ${habit.name}
  Streak: ${habit.streak} days
  Points: ${habit.points}
  Status: ${habit.streak > 7 ? 'Excellent!' : 'Keep going!'}
`;

// Tagged templates for custom processing
function sql(strings, ...values) {
  return {
    query: strings.join('?'),
    values: values
  };
}

const query = sql`
  SELECT * FROM habits 
  WHERE category = ${category} 
  AND points > ${minPoints}
`;
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Optional Chaining & Nullish Coalescing
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Optional chaining (?.) - safe property access
const userName = user?.profile?.name;
const firstHabit = habits?.[0]?.name;
const result = calculateStats?.();

// Nullish coalescing (??) - default for null/undefined only
const port = process.env.PORT ?? 3000;
const theme = userPrefs.theme ?? 'light';

// Combining both
const city = user?.address?.city ?? 'Unknown';

// Logical assignment operators
let score = 0;
score ||= 10;  // score = score || 10
score &&= 5;   // score = score && 5
score ??= 1;   // score = score ?? 1
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Modern Array Methods
    <Box width="80%">
      <Text fontSize="20px" fontWeight="bold" marginBottom="20px">ES6+:</Text>
      - find() / findIndex() - get first match
      - includes() - check existence
      - flat() / flatMap() - flatten arrays
      - from() - create from iterables
      <Text fontSize="20px" fontWeight="bold" marginTop="30px" marginBottom="20px">ES2023:</Text>
      - toSorted() - sort without mutation
      - toReversed() - reverse without mutation
      - with() - update element immutably
    </Box>
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Modern Habit Dashboard
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Build a modern habit dashboard using latest features
// TODO: Implement these features using modern JavaScript

class HabitDashboard {
  #habits = [];
  #settings = {
    theme: 'light',
    notifications: true
  };
  
  // TODO: Implement these methods using modern features:
  // 1. addHabits(...habits) - add multiple habits
  // 2. getHabitsByTags(tags) - filter by multiple tags
  // 3. generateReport() - create summary with template literals
  // 4. updateSettings(updates) - merge settings immutably
  
  // Your implementation here...
}

// Test your implementation
const dashboard = new HabitDashboard();
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Modern JavaScript Ecosystem
**Build Tools:**
- Vite, Webpack, Parcel, esbuild

**Package Managers:**
- npm, yarn, pnpm

**Frameworks:**
- React, Vue, Angular, Svelte

**Testing:**
- Jest, Vitest, Mocha, Cypress
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## ðŸŽ¯ Key Takeaways: Modern JavaScript

1. **Destructuring** makes code cleaner and more expressive
2. **Spread/Rest** operators enable flexible data handling
3. **Optional chaining** and **nullish coalescing** prevent errors
4. **Template literals** go beyond simple string interpolation
5. **Modern classes** provide encapsulation with private fields
6. **New array methods** make data transformation easier

### Coming Up Next: Common Pitfalls
Learn to avoid JavaScript's tricky parts!
</SlideLayout.Full>