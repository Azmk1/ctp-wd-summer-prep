import { SlideLayout, Image, FlexBox, Box, Text} from 'spectacle'

<SlideLayout.Full>
## Asynchronous JavaScript
### Handling Time and External Resources
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
## Why Asynchronous?
    
- JavaScript is single-threaded
- Can't block while waiting for slow operations
- Network requests, file I/O, timers need async
- Enables responsive user interfaces
    
**Real-world analogy:**
- Restaurant kitchen - take orders while cooking
- Don't wait for one meal before starting next
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## Synchronous vs Asynchronous
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Synchronous - blocks execution
console.log("1. Starting habit sync");
const data = loadHabitsFromFile(); // Blocks here!
console.log("2. Got data:", data);
console.log("3. Done");

// Asynchronous - non-blocking
console.log("1. Starting habit sync");
loadHabitsAsync((data) => {
  console.log("3. Got data:", data);
});
console.log("2. Continuing..."); // Runs immediately!

// Output order: 1, 2, 3 (not 1, 3, 2!)
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
## Evolution of Async Patterns
**1. Callbacks (Traditional)**
- Function passed as argument
- Called when operation completes
- Can lead to "callback hell"

**2. Promises (ES6)**
- Object representing future value
- Chainable with .then() and .catch()
- Better error handling

**3. Async/Await (ES2017)**
- Write async code that looks synchronous
- Built on top of Promises
- Cleaner, more readable code
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## JavaScript's Event Loop
  <FlexBox alignItems="center" justifyContent="center" flexDirection="row">
    <Image src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZmFqM2x1NW84NjcxaXczNHYzbjZwbm5mbTh3ZmIwMGg5MGo4bHJnaSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/CHtJn4SZurPa5LtV2w/giphy.gif" />
    - JavaScript is single-threaded but non-blocking
    - The event loop handles asynchronous operations
    - Callbacks, promises, and async/await manage async code
    - Understanding async is crucial for modern JavaScript
    </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## Callbacks: The Traditional Way
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Callbacks - functions passed as arguments
function loadHabitData(habitId, callback) {
  // Simulate network request
  setTimeout(() => {
    const data = { id: habitId, name: "Exercise", streak: 5 };
    callback(data);
  }, 1000);
}

// Usage - provide function to call when done
loadHabitData(123, (habitData) => {
  console.log("Got habit:", habitData.name);
});

// Problem: Callback hell with multiple operations
loadHabitData(123, (habitData) => {
  updateHabitStreak(habitData.id, (result) => {
    saveToDatabase(result, (saved) => {
      console.log("All done!"); // Nested callbacks get messy
    });
  });
});
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Promises: A Better Way
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Promises - objects representing future values
function loadHabitData(habitId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { id: habitId, name: "Exercise", streak: 5 };
      resolve(data); // Success!
      // reject(new Error("Failed")); // For errors
    }, 1000);
  });
}

// Usage with .then() and .catch()
loadHabitData(123)
  .then(habitData => {
    console.log("Got habit:", habitData.name);
    return updateHabitStreak(habitData.id);
  })
  .then(result => {
    return saveToDatabase(result);
  })
  .then(saved => {
    console.log("All done!");
  })
  .catch(error => {
    console.error("Something failed:", error);
  });
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Async/Await: The Modern Way
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Async/await - makes async code look synchronous
async function processHabit(habitId) {
  try {
    // await pauses execution until Promise resolves
    const habitData = await loadHabitData(habitId);
    console.log("Got habit:", habitData.name);
    
    const result = await updateHabitStreak(habitData.id);
    const saved = await saveToDatabase(result);
    
    console.log("All done!");
    return saved;
  } catch (error) {
    console.error("Something failed:", error);
    throw error; // Re-throw if needed
  }
}

// Usage - async functions return Promises
processHabit(123)
  .then(result => console.log("Success:", result))
  .catch(error => console.log("Failed:", error));
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Async/Await Rules

**Key concepts to remember:**

**The `async` keyword:**
- Makes a function return a Promise automatically
- Allows use of `await` inside the function

**The `await` keyword:**
- Can only be used inside `async` functions
- Pauses execution until the Promise resolves
- Returns the resolved value (not the Promise)

**Error handling:**
- Use `try/catch` blocks with async/await
- Much cleaner than `.catch()` chains

**Real benefit:** Write asynchronous code that reads like synchronous code!

</SlideLayout.Full>

<SlideLayout.Full>
## Asynchronous JavaScript
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Understanding async patterns in habit tracking
// TODO: Convert these examples to use modern async/await

// 1. Callbacks - saving habit completion
function saveHabitCompletion(habitId, callback) {
  setTimeout(() => {
    callback({ success: true, points: 10 });
  }, 1000);
}

// 2. Promises - fetching habit data
function getHabitData(habitId) {
  return fetch(`/api/habits/${habitId}`)
    .then(response => response.json());
}

// 3. TODO: Create async function to save and update
// Should save completion, then fetch updated data
```
    
    
```javascript
// Solution: Modern async/await patterns
// 1. Converting callback to Promise
function saveHabitCompletion(habitId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ success: true, points: 10 });
    }, 1000);
  });
}

// 2. Async/await version of data fetching
async function getHabitData(habitId) {
  const response = await fetch(`/api/habits/${habitId}`);
  return await response.json();
}

// 3. Complete async function that saves and updates
async function saveAndUpdateHabit(habitId, completionData) {
  try {
    // Save the completion
    const saveResult = await saveHabitCompletion(habitId);
    console.log('Saved:', saveResult);
    
    // Fetch updated data
    const updatedData = await getHabitData(habitId);
    console.log('Updated data:', updatedData);
    
    return {
      saveResult,
      updatedData
    };
  } catch (error) {
    console.error('Error in save and update:', error);
    throw error;
  }
}

// Usage example
async function handleHabitCompletion() {
  try {
    const result = await saveAndUpdateHabit('habit-123');
    console.log('Process completed:', result);
  } catch (error) {
    console.error('Failed to complete habit:', error);
  }
}

// Simulated API functions for testing
function fetch(url) {
  return Promise.resolve({
    json: () => Promise.resolve({
      id: 'habit-123',
      name: 'Exercise',
      streak: 5,
      lastCompleted: new Date().toISOString()
    })
  });
}
```
    
  </File>
  <Tests>
    
```javascript
// Tests for Async JavaScript
describe('Async Habit Tracking', () => {
  it('should save habit completion asynchronously', async () => {
    const result = await saveHabitCompletion('test-habit');
    expect(result.success).to.be.true;
    expect(result.points).to.equal(10);
  });
  
  it('should fetch habit data with async/await', async () => {
    const data = await getHabitData('habit-123');
    expect(data).to.have.property('id');
    expect(data.name).to.equal('Exercise');
  });
  
  it('should save and update habit in sequence', async () => {
    const result = await saveAndUpdateHabit('habit-123');
    expect(result).to.have.property('saveResult');
    expect(result).to.have.property('updatedData');
    expect(result.saveResult.success).to.be.true;
  });
});
```
    
  </Tests>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Promise Basics
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Creating a Promise
const myPromise = new Promise((resolve, reject) => {
  // Async operation here
  setTimeout(() => {
    if (Math.random() > 0.5) {
      resolve("Success!");
    } else {
      reject("Failed!");
    }
  }, 1000);
});

// Using a Promise
myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error))
  .finally(() => console.log("Done either way"));

// Promise states:
// - Pending: initial state
// - Fulfilled: operation completed successfully
// - Rejected: operation failed
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
## Common Async Patterns
**Real-world scenarios in habit tracking:**
- Fetching user habits from API
- Saving completion to database
- Syncing data across devices
- Loading user preferences
- Uploading progress photos

**Remember:**
- Network requests are always async
- File operations are async in Node.js
- setTimeout/setInterval are async
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## Understanding Promise Chains vs Async/Await

**Promise Chains** (older style):
```javascript
getData()
  .then(data => processData(data))
  .then(processed => saveData(processed))
  .then(result => console.log('Success:', result))
  .catch(error => console.error('Failed:', error));
```

**Async/Await** (modern style):
```javascript
async function handleData() {
  try {
    const data = await getData();
    const processed = await processData(data);
    const result = await saveData(processed);
    console.log('Success:', result);
  } catch (error) {
    console.error('Failed:', error);
  }
}
```

**Why Async/Await is Better:**
- Looks like synchronous code (easier to read)
- Better error handling with try/catch
- Easier debugging and stack traces
- Less nesting and callback complexity
</SlideLayout.Full>

<SlideLayout.Full>
## Converting Patterns: Callbacks → Promises → Async/Await

**Step 1: Callback to Promise**
```javascript
// Callback version
function saveData(data, callback) {
  setTimeout(() => callback(null, { success: true }), 1000);
}

// Promise version  
function saveData(data) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ success: true }), 1000);
  });
}
```

**Step 2: Promise Chain to Async/Await**
```javascript
// Promise chain
return saveData(data)
  .then(result => updateUI(result))
  .then(ui => logActivity(ui));

// Async/await
const result = await saveData(data);
const ui = await updateUI(result);
return await logActivity(ui);
```

**For the exercise**: Convert a complex promise chain into clean async/await code.
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Promise Chain to Async/Await
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Convert habit sync promise chain to async/await
// TODO: This function syncs habit data with a server
// Convert the promise chain to use async/await

function syncHabitData(habitId) {
  // First, get local habit data
  return getLocalHabitData(habitId)
    .then(localData => {
      // Then, send to server
      return fetch(`/api/habits/${habitId}/sync`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(localData)
      });
    })
    .then(response => response.json())
    .then(serverData => {
      // Update local storage with server response
      localStorage.setItem(`habit_${habitId}`, JSON.stringify(serverData));
      console.log('Sync complete:', serverData);
      return serverData;
    })
    .catch(error => {
      console.error('Sync failed:', error);
      throw error;
    });
}

// Helper function (given)
function getLocalHabitData(habitId) {
  return Promise.resolve({
    id: habitId,
    completions: ["2024-01-01", "2024-01-02"],
    lastSync: new Date().toISOString()
  });
}
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Async/Await Best Practices
<CodeDisplay >
  <File name="example.js">
    
```javascript
// DO: Use try/catch for error handling
async function saveHabit() {
  try {
    const result = await api.save(habit);
    return result;
  } catch (error) {
    console.error('Save failed:', error);
    throw error;
  }
}

// DO: Run independent operations in parallel
const [habits, user, settings] = await Promise.all([
  fetchHabits(),
  fetchUser(),
  fetchSettings()
]);

// DON'T: Await in loops (slow)
for (const habit of habits) {
  await saveHabit(habit); // Sequential - slow!
}

// DO: Use Promise.all for parallel operations
await Promise.all(habits.map(habit => saveHabit(habit)));
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Key Takeaways: Asynchronous JavaScript

**Remember:**
- JavaScript is single-threaded but non-blocking
- Callbacks → Promises → Async/Await (evolution)
- Always handle errors in async code
- Use Promise.all() for parallel operations
- Async/await makes code more readable

**Common Pitfalls:**
- Forgetting to await async functions
- Not handling promise rejections
- Creating sequential code when parallel would work

*Master async patterns for responsive, modern web apps!*

### Bridge to Error Handling
Async code can fail. Let's learn how to **handle errors gracefully** and build robust applications!
</SlideLayout.Full>