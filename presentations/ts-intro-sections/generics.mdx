import { SlideLayout, Image, FlexBox, Box, Text } from 'spectacle'

<SlideLayout.Full>
## What Are Generics?

**Generics are "type variables" that make code reusable:**
- Write functions/classes that work with multiple types
- Maintain type safety without code duplication
- Think of them as "placeholders" for types

**The `<T>` Syntax:**
```typescript
// T is a type variable (can be any name)
function identity<T>(value: T): T {
  return value;
}

// TypeScript infers the type
const num = identity(42);        // T = number
const str = identity("hello");   // T = string

// Or specify explicitly
const bool = identity<boolean>(true);
```

**Common Generic Names:**
- `T` - Type
- `K` - Key
- `V` - Value  
- `E` - Element
</SlideLayout.Full>

<SlideLayout.Full>
## Arrays and Generics

- Arrays can be typed in two ways
- Generics allow types to be flexible but safe
- Think of generics as "type functions" with argument types and a return type

```typescript
// Two ways to type arrays
let numbers: number[] = [1, 2, 3];
let strings: Array<string> = ["a", "b", "c"];

// Generic function
function identity<T>(value: T): T {
  return value;
}

identity<string>("hello"); // Returns string
identity<number>(42); // Returns number
```
</SlideLayout.Full>

<SlideLayout.Full>
## Understanding Generic Programming

Generics allow you to write code that works with multiple types safely:

**The Problem Without Generics:**
```typescript
// Need separate classes for each type
class NumberBox { 
  constructor(private value: number) {}
  getValue(): number { return this.value; }
}

class StringBox {
  constructor(private value: string) {}
  getValue(): string { return this.value; }
}
```

**The Solution With Generics:**
```typescript
// One class works with any type
class Box<T> {
  constructor(private value: T) {}
  getValue(): T { return this.value; }
}
```

**Benefits**: Less code duplication, type safety, flexibility
</SlideLayout.Full>

<SlideLayout.Full>
## Generic Syntax and Patterns

**Generic Classes:**
```typescript
class Container<T> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  get(index: number): T | undefined {
    return this.items[index];
  }
}
```

**Generic Functions:**
```typescript
function identity<T>(value: T): T {
  return value;
}

function getFirst<T>(items: T[]): T | undefined {
  return items[0];
}
```

**For the exercise**: Transform a class that uses `any` into a type-safe generic class that preserves type information.
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Build a Generic Container
<CodeDisplay >
  <File name="example.typescript">
    
```typescript
// Create a generic Box class that can hold any type of value
// It should have methods to get and set the value

class Box {
  // TODO: Make this generic!
  private value: any;
  
  constructor(initial: any) {
    this.value = initial;
  }
  
  getValue(): any {
    return this.value;
  }
  
  setValue(newValue: any): void {
    this.value = newValue;
  }
}

// This should work with proper generics
const numberBox = new Box(42);
const num: number = numberBox.getValue(); // Should be type-safe

const stringBox = new Box("hello");
const str: string = stringBox.getValue(); // Should be type-safe
```
    
    
```typescript
// Solution: Generic Box class
class Box<T> {
  private value: T;
  
  constructor(initial: T) {
    this.value = initial;
  }
  
  getValue(): T {
    return this.value;
  }
  
  setValue(newValue: T): void {
    this.value = newValue;
  }
  
  // Additional utility methods
  isEmpty(): boolean {
    return this.value === null || this.value === undefined;
  }
  
  transform<U>(transformer: (value: T) => U): Box<U> {
    return new Box(transformer(this.value));
  }
}

// Usage examples with type safety
const numberBox = new Box<number>(42);
const num: number = numberBox.getValue(); // Type-safe!

const stringBox = new Box<string>("hello");
const str: string = stringBox.getValue(); // Type-safe!

// Transform box contents
const lengthBox = stringBox.transform(s => s.length);
const length: number = lengthBox.getValue(); // Returns number

// Array box
const arrayBox = new Box<number[]>([1, 2, 3]);
arrayBox.setValue([4, 5, 6]);

//***
describe('Generic Box - Complete Implementation', () => {
  it('should store and retrieve values', () => {
    const testBox = new Box<number>(100);
    expect(testBox.getValue()).to.equal(100);
  });
  
  it('should update values correctly', () => {
    const testBox = new Box<number>(100);
    testBox.setValue(200);
    expect(testBox.getValue()).to.equal(200);
  });
  
  it('should work with different types', () => {
    const stringBox = new Box<string>("test");
    const boolBox = new Box<boolean>(true);
    
    expect(stringBox.getValue()).to.equal("test");
    expect(boolBox.getValue()).to.be.true;
  });
  
  it('should transform box contents', () => {
    const stringBox = new Box<string>("hello");
    const lengthBox = stringBox.transform(s => s.length);
    expect(lengthBox.getValue()).to.equal(5);
  });
});
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Building Generic Data Structures

Real applications need flexible storage systems:

**Generic Storage Requirements:**
- Store items of any type safely
- Provide CRUD operations (Create, Read, Update, Delete)
- Maintain type safety throughout operations
- Allow searching and filtering

**Generic Constraints for Practical Use:**
```typescript
// Constraint: items must have an 'id' property
interface Identifiable {
  id: string;
}

class Storage<T extends Identifiable> {
  private items: T[] = [];
  
  add(item: T): void { /* ... */ }
  getById(id: string): T | undefined { /* ... */ }
}
```

**The Challenge**: Build a storage system that works with any object type while ensuring they have the properties needed for storage operations.
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Generic Habit Storage
<CodeDisplay >
  <File name="example.typescript">
    
```typescript
// Exercise: Create a generic storage class for habits
// TODO: Implement a type-safe storage system

class Storage {
  // TODO: Make this generic to work with any type
  private items: any[] = [];
  
  add(item: any): void {
    // Your code here
  }
  
  getById(id: string): any {
    // Your code here
  }
  
  getAll(): any[] {
    // Your code here
  }
  
  update(id: string, updates: any): boolean {
    // Your code here
  }
  
  remove(id: string): boolean {
    // Your code here
  }
}

// Test with habits
interface Habit {
  id: string;
  name: string;
  streak: number;
}

const habitStorage = new Storage();
habitStorage.add({ id: "1", name: "Exercise", streak: 5 });
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Generic Constraints: extends keyword

**1. extends keyword**
- Limit generic to types with certain properties
- Ensure type safety while maintaining flexibility
- Access properties of the constrained type

```typescript
// Constraint: T must have an id property
function updateRecord<T extends { id: number }>(record: T, updates: Partial<T>): T {
  return { ...record, ...updates };
}

interface User { id: number; name: string; email: string; }
interface Product { id: number; title: string; price: number; }

const user = updateRecord({ id: 1, name: "Alice", email: "alice@example.com" }, { name: "Alice Smith" });
const product = updateRecord({ id: 2, title: "Laptop", price: 999 }, { price: 899 });

// Error: string doesn't have id property
// updateRecord("hello", {});
```
</SlideLayout.Full>

<SlideLayout.Full>
## Generic Constraints: Multiple constraints

**2. Multiple constraints**
- Combine interfaces with &
- Create complex type requirements
- Build reusable, type-safe utilities

```typescript
// Multiple constraints with &
interface Identifiable { id: number; }
interface Timestamped { createdAt: Date; updatedAt: Date; }

function processEntity<T extends Identifiable & Timestamped>(
  entity: T
): T & { processed: true } {
  return {
    ...entity,
    updatedAt: new Date(),
    processed: true
  };
}

// Must have both id and timestamp properties
const habit = processEntity({
  id: 1,
  name: "Exercise",
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-01')
});
```
</SlideLayout.Full>

<SlideLayout.Full>
## Generic Constraints: Default generics

**3. Default generics**
- Provide default types for convenience
- Make APIs easier to use
- Maintain backwards compatibility

```typescript
// Default generic type
interface ApiResponse<T = unknown> {
  data: T;
  status: number;
  message: string;
}

// Use with specific type
const userResponse: ApiResponse<User> = {
  data: { id: 1, name: "Alice", email: "alice@example.com" },
  status: 200,
  message: "Success"
};

// Use with default (unknown)
const genericResponse: ApiResponse = {
  data: { anything: "goes here" },
  status: 200, 
  message: "Success"
};

// Function with default generic
function createArray<T = string>(length: number, defaultValue: T): T[] {
  return Array(length).fill(defaultValue);
}

const strings = createArray(3, "hello"); // string[]
const numbers = createArray(3, 42); // number[]
```
</SlideLayout.Full>

<SlideLayout.Full>
## Understanding Generic Functions for Data Processing

Generic functions are powerful for data transformation:

**Generic Function Patterns:**
```typescript
// Transform array elements
function map<T, U>(items: T[], transform: (item: T) => U): U[] {
  return items.map(transform);
}

// Group items by a property
function groupBy<T, K extends keyof T>(items: T[], key: K): Record<string, T[]> {
  // Implementation here
}

// Filter with type safety
function filter<T>(items: T[], predicate: (item: T) => boolean): T[] {
  return items.filter(predicate);
}
```

**Benefits:**
- Type safety for input and output
- Reusable with any data type
- IntelliSense support for properties
- Compile-time error checking

**For the exercise**: Build generic utilities that work with habit data while preserving all type information.
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Generic Data Transformers
<CodeDisplay >
  <File name="example.typescript">
    
```typescript
// Exercise: Build generic data transformation utilities
// TODO: Create type-safe transform functions

// TODO: Make this function generic
function mapArray(items: any[], transform: (item: any) => any): any[] {
  // Your code here
}

// TODO: Create a generic groupBy function
function groupBy(items: any[], key: string): any {
  // Your code here
}

// Test with habits
const habits = [
  { id: "1", name: "Exercise", category: "health", points: 50 },
  { id: "2", name: "Meditate", category: "wellness", points: 30 },
  { id: "3", name: "Read", category: "learning", points: 40 },
  { id: "4", name: "Water", category: "health", points: 20 }
];

// Should work with type safety
const names = mapArray(habits, h => h.name);
const grouped = groupBy(habits, "category");
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Generic Constraints
<CodeDisplay >
  <File name="example.typescript">
    
```typescript
// Constrain generics to certain types
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(item: T): T {
  console.log(item.length);
  return item;
}

logLength("hello"); // OK - strings have length
logLength([1, 2, 3]); // OK - arrays have length
logLength({ length: 10 }); // OK - has length property
// logLength(123); // Error - numbers don't have length

// Multiple constraints
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Built-in Generic Types
<CodeDisplay >
  <File name="example.typescript">
    
```typescript
// Promise<T> - Async values
const promise: Promise<string> = fetch('/api').then(r => r.text());

// Array<T> - Lists of values
const numbers: Array<number> = [1, 2, 3];

// Map<K, V> - Key-value pairs
const userMap: Map<number, string> = new Map();
userMap.set(1, "Alice");

// Set<T> - Unique values
const uniqueNumbers: Set<number> = new Set([1, 2, 2, 3]);

// Record<K, V> - Object with specific key/value types
const scores: Record<string, number> = {
  alice: 100,
  bob: 95
};
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Common Generic Pitfalls

**Avoid these common mistakes:**

1. **Over-constraining generics**
```typescript
// ❌ Too restrictive
function process<T extends { id: string, name: string, age: number }>(item: T) { }

// ✅ Better - only constrain what you need
function process<T extends { id: string }>(item: T) { }
```

2. **Not using inference**
```typescript
// ❌ Unnecessary type annotation
const result = identity<string>("hello");

// ✅ Let TypeScript infer
const result = identity("hello");
```

3. **Generic overuse**
```typescript
// ❌ Generic when not needed
function getUserName<T extends User>(user: T): string {
  return user.name;
}

// ✅ Simple is better
function getUserName(user: User): string {
  return user.name;
}
```
</SlideLayout.Full>

<SlideLayout.Full>
## 🎯 Key Takeaways: Generics

1. **Generics make code reusable** without sacrificing type safety
2. **Use constraints** to ensure minimum requirements
3. **Default generics** provide fallback types
4. **Built-in generics** like Promise<T> and Array<T> are everywhere
5. **Keep it simple** - don't over-engineer with generics

### Bridge to Type Guards
Generics help us write flexible code, but we still need to **narrow types** at runtime. Let's explore type guards!
</SlideLayout.Full>