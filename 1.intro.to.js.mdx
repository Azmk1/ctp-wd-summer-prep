import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Full>
  ## Intro To JavaScript
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    <Image height="400px" width="400px" src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExYnZ4MGx4YWR5djFmaXIza2dvaWNvMnlvcGVtOWw0cHJvY29iZTZqMiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/fuJPZBIIqzbt1kAYVc/giphy.gif" />
  </FlexBox>
</SlideLayout.Full>
<SlideLayout.Center>
  ## What is JavaScript
  - JavaScript is a dynamic programming language that powers the web
  - Originally created to make web pages interactive
  - Now runs everywhere: browsers, servers, mobile apps, IoT devices
  - It's the most popular programming language in the world
</SlideLayout.Center>

<SlideLayout.Center>
## A Brief History

- Created by Brendan Eich in just 10 days (1995)
- Originally called "Mocha", then "LiveScript", finally "JavaScript"

<Image src="https://ctp-presentation-media.s3.us-east-2.amazonaws.com/History+of+JavaScript+-+visual+selection.svg" width="100%" />
</SlideLayout.Center>

<SlideLayout.Center>
## JavaScript is Everywhere
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">

    <Image objectFit="contain" imgContainerProps={{
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        margin: '0 auto',
        width: '900px',
      }
    }}
    src="https://ctp-presentation-media.s3.us-east-2.amazonaws.com/JavaScript+is+Everywhere+-+visual+selection.svg" />
  </FlexBox>
</SlideLayout.Center>
<SlideLayout.Center>
## Variables in JavaScript

```javascript
// Old way (function-scoped)
var name = "Alice";

// Modern way (block-scoped)
let age = 25;
const isStudent = true;

// const means the reference can't change
const person = { name: "Bob" };
person.name = "Charlie"; // This works!
// person = {}; // This doesn't!
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Variable Scoping

```javascript
// Fix this code to print "Inside" then "Outside"
var message = "Outside";

if (true) {
  var message = "Inside";
  console.log(message);
}

console.log(message); // This prints "Inside" - why?

// ***
// Test: We want "Inside" then "Outside", but var doesn't respect block scope
// This test will FAIL until you fix the scoping issue
const outputs = [];
var testMessage = "Outside";

if (true) {
  var testMessage = "Inside";
  outputs.push(testMessage);
}
outputs.push(testMessage);

if (outputs[0] !== "Inside" || outputs[1] !== "Outside") {
  throw new Error(`Expected ["Inside", "Outside"] but got ["${outputs[0]}", "${outputs[1]}"]`);
}
// ---
// Step 1: Understand the problem - var is function-scoped
var message = "Outside";

if (true) {
  var message = "Inside"; // This overwrites the outer variable!
  console.log(message);
}

console.log(message); // "Inside" - var doesn't respect block scope

// ***
// Test confirms the problem - var doesn't respect block scope
if (message !== "Inside") {
  throw new Error(`Expected message to be "Inside", but got "${message}"`);
}
// ---
// Step 2: Fix using let for block scoping
let message = "Outside";
let innerMessage = "";
let outerMessage = "";

if (true) {
  let message = "Inside"; // This creates a new block-scoped variable
  console.log(message);    // "Inside"
  innerMessage = message;
}

console.log(message);      // "Outside"
outerMessage = message;

// ***
// Test: Now we should see "Inside" then "Outside"
if (innerMessage !== "Inside") {
  throw new Error(`Expected inner message to be "Inside", but got "${innerMessage}"`);
}
if (outerMessage !== "Outside") {
  throw new Error(`Expected outer message to be "Outside", but got "${outerMessage}"`);
}
```
</SlideLayout.Center>

<SlideLayout.Full>
## JavaScript Data Types
  <FlexBox alignItems="center" justifyContent="center" flexDirection="row">
    <Box width="100%" height="100%">
      **Primitives:**
      - `undefined`
      - `null`
      - `boolean`
      - `number`
      - `bigint`
      - `string`
      - `symbol`
    </Box>
    <Box width="100%" height="100%">
      **Objects:**
      - `Object`
      - `Array`
      - `Function`
      - `Date`
      - `RegExp`
      - `Map/Set`
      - `Promise`
    </Box>
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Full>
## Data Types in Action
```javascript
// Primitives
let undef;                          // undefined
let nothing = null;                 // null
let isActive = true;                // boolean
let count = 42;                     // number
let bigNumber = 9007199254740991n;  // bigint
let message = "Hello, JavaScript!"; // string
let unique = Symbol("id");          // symbol

// Objects
let obj = { key: "value" };         // object
let nums = [1, 2, 3];               // array
let greet = () => "Hello!";         // function
let now = new Date();               // date
let pattern = /[a-z]+/;             // regexp
let map = new Map();                // map
let promise = Promise.resolve(42);  // promise
```
</SlideLayout.Full>

<SlideLayout.Center>
## JavaScript's Flexibility Problem

<FlexBox alignItems="center" justifyContent="center" flexDirection="column">

What happens here?

```javascript
console.log("5" + 3);        // "53"
console.log("5" - 3);        // 2
console.log(true + true);    // 2
console.log([] + {});        // "[object Object]"
// ---
console.log("5" + 3);        // "53" (string concatenation)
console.log("5" - 3);        // 2 (converts to number)
console.log(true + true);    // 2 (true = 1)
console.log([] + {});        // "[object Object]"
```
</FlexBox>
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Type Conversion

```javascript
// Predict the output, then fix to get numeric addition
const userInput = "42";
const bonus = 8;
const total = userInput + bonus;

console.log(total); // What will this print?
console.log(typeof total); // What type is it?

// ***
// Test: We want 50 (numeric addition), not "428" (string concatenation)
// This test will FAIL until you fix the type conversion
if (total !== 50) {
  throw new Error(`Expected 50 but got "${total}" (type: ${typeof total})`);
}
if (typeof total !== "number") {
  throw new Error(`Expected type "number" but got "${typeof total}"`);
}
// ---
// Step 1: Understanding the problem
const userInput = "42";
const bonus = 8;
const total = userInput + bonus; // "42" + 8 = "428"

console.log(total);        // "428" - string concatenation!
console.log(typeof total); // "string"

// ***
// Test confirms the type coercion issue
if (total !== "428" || typeof total !== "string") {
  throw new Error("Type coercion didn't work as expected");
}
// ---
// Step 2: Convert string to number using Number()
const userInput = "42";
const bonus = 8;
const total = Number(userInput) + bonus;

console.log(total);        // 50
console.log(typeof total); // "number"

// ***
// Test: Now we should get proper numeric addition
if (total !== 50) {
  throw new Error(`Expected 50 but got ${total}`);
}
if (typeof total !== "number") {
  throw new Error(`Expected type "number" but got "${typeof total}"`);
}
// ---
// Step 3: Alternative solutions
const userInput = "42";
const bonus = 8;

// Using parseInt
const total1 = parseInt(userInput) + bonus; // 50
console.log("parseInt:", total1);

// Using unary plus
const total2 = +userInput + bonus; // 50
console.log("unary plus:", total2);

// Using Number constructor
const total3 = Number(userInput) + bonus; // 50
console.log("Number():", total3);

// ***
// Test: All methods should produce the same result
if (total1 !== 50 || total2 !== 50 || total3 !== 50) {
  throw new Error("Not all conversion methods produced 50");
}
// Edge case: what about invalid input?
const invalidInput = "abc";
if (!isNaN(parseInt(invalidInput))) {
  throw new Error("parseInt should return NaN for invalid input");
}
```
</SlideLayout.Center>

<SlideLayout.Full>
## Type Coercion: Feature or Bug?
<FlexBox alignItems="center" justifyContent="center" flexDirection="row">
  <Image src="https://media2.giphy.com/media/3o7TKTDn976rzVgky4/giphy.gif" width="50%" />
  
  - JavaScript tries to be helpful by converting types automatically
  - This can lead to unexpected behavior
  - Understanding type coercion is crucial for writing bug-free code
  - Modern tools like TypeScript help catch these issues
  </FlexBox>
</SlideLayout.Full>

<SlideLayout.Center>
## Functions: The Heart of JavaScript

```javascript
// Function declaration
function add(a, b) {
  return a + b;
}

// Function expression
const multiply = function(a, b) {
  return a * b;
};

// Arrow function (ES6+)
const divide = (a, b) => a / b;

// Functions are first-class citizens
const operation = add;
console.log(operation(5, 3)); // 8
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Function Calculator

```javascript
// Create a calculator function that takes an operation and two numbers
// calculator("add", 5, 3) should return 8
// calculator("multiply", 4, 7) should return 28

function calculator(operation, a, b) {
  // Your code here
}

console.log(calculator("add", 5, 3));
console.log(calculator("multiply", 4, 7));
console.log(calculator("divide", 10, 2));

// ***
// Test: These tests will FAIL until you implement the calculator
if (calculator("add", 5, 3) !== 8) {
  throw new Error(`add(5,3) should return 8, got ${calculator("add", 5, 3)}`);
}
if (calculator("multiply", 4, 7) !== 28) {
  throw new Error(`multiply(4,7) should return 28, got ${calculator("multiply", 4, 7)}`);
}
if (calculator("divide", 10, 2) !== 5) {
  throw new Error(`divide(10,2) should return 5, got ${calculator("divide", 10, 2)}`);
}
// ---
// Step 1: Using if/else statements
function calculator(operation, a, b) {
  if (operation === "add") {
    return a + b;
  } else if (operation === "multiply") {
    return a * b;
  } else if (operation === "divide") {
    return a / b;
  } else if (operation === "subtract") {
    return a - b;
  }
}

console.log(calculator("add", 5, 3));      // 8
console.log(calculator("multiply", 4, 7)); // 28
console.log(calculator("divide", 10, 2));  // 5

// ***
// Test basic operations
if (calculator("add", 5, 3) !== 8) {
  throw new Error(`Expected 8, got ${calculator("add", 5, 3)}`);
}
if (calculator("multiply", 4, 7) !== 28) {
  throw new Error(`Expected 28, got ${calculator("multiply", 4, 7)}`);
}
if (calculator("divide", 10, 2) !== 5) {
  throw new Error(`Expected 5, got ${calculator("divide", 10, 2)}`);
}
if (calculator("subtract", 10, 3) !== 7) {
  throw new Error(`Expected 7, got ${calculator("subtract", 10, 3)}`);
}
// Test undefined operation
if (calculator("power", 2, 3) !== undefined) {
  throw new Error("Should return undefined for unknown operations");
}
// ---
// Step 2: Using an object to map operations
function calculator(operation, a, b) {
  const operations = {
    add: (x, y) => x + y,
    subtract: (x, y) => x - y,
    multiply: (x, y) => x * y,
    divide: (x, y) => x / y
  };
  
  return operations[operation](a, b);
}

console.log(calculator("add", 5, 3));      // 8
console.log(calculator("multiply", 4, 7)); // 28
console.log(calculator("divide", 10, 2));  // 5

// ***
// Same tests should pass
if (calculator("add", 5, 3) !== 8) {
  throw new Error("Add operation failed");
}
if (calculator("multiply", 4, 7) !== 28) {
  throw new Error("Multiply operation failed");
}
// This will now throw an error for unknown operations
try {
  calculator("power", 2, 3);
  throw new Error("Should have thrown an error for unknown operation");
} catch (e) {
  // Expected behavior
}
// ---
// Step 3: Add error handling
function calculator(operation, a, b) {
  const operations = {
    add: (x, y) => x + y,
    subtract: (x, y) => x - y,
    multiply: (x, y) => x * y,
    divide: (x, y) => y !== 0 ? x / y : "Cannot divide by zero"
  };
  
  if (!operations[operation]) {
    return "Invalid operation";
  }
  
  return operations[operation](a, b);
}

console.log(calculator("add", 5, 3));       // 8
console.log(calculator("divide", 10, 0));   // "Cannot divide by zero"
console.log(calculator("power", 2, 3));     // "Invalid operation"

// ***
// Test error handling
if (calculator("add", 5, 3) !== 8) {
  throw new Error("Add operation failed");
}
if (calculator("divide", 10, 0) !== "Cannot divide by zero") {
  throw new Error("Division by zero not handled properly");
}
if (calculator("power", 2, 3) !== "Invalid operation") {
  throw new Error("Invalid operation not handled properly");
}
// Test edge cases
if (calculator("add", -5, 3) !== -2) {
  throw new Error("Negative numbers not handled correctly");
}
if (calculator("multiply", 0, 100) !== 0) {
  throw new Error("Multiplication by zero failed");
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Control Flow

```javascript
// If/else
if (age >= 18) {
  console.log("Adult");
} else {
  console.log("Minor");
}

// Ternary operator
const status = age >= 18 ? "Adult" : "Minor";

// Switch
switch (day) {
  case "Monday":
    console.log("Start of the week");
    break;
  case "Friday":
    console.log("TGIF!");
    break;
  default:
    console.log("Regular day");
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Loops and Iteration

```javascript
// Traditional for loop
for (let i = 0; i < 5; i++) {
  console.log(i);
}

// For...of (values)
const fruits = ["apple", "banana", "orange"];
for (const fruit of fruits) {
  console.log(fruit);
}

// For...in (keys/indices)
const person = { name: "Alice", age: 30 };
for (const key in person) {
  console.log(key, person[key]);
}

// Array methods
fruits.forEach(fruit => console.log(fruit));
const upperFruits = fruits.map(f => f.toUpperCase());
```
</SlideLayout.Center>

<SlideLayout.Center>
## Objects: JavaScript's Building Blocks

```javascript
// Object literal
const user = {
  name: "John",
  age: 25,
  greet() {
    return `Hi, I'm ${this.name}`;
  }
};

// Accessing properties
console.log(user.name);      // Dot notation
console.log(user["age"]);    // Bracket notation

// Destructuring (ES6+)
const { name, age } = user;

// Spread operator (ES6+)
const updatedUser = { ...user, age: 26 };
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Building a Shopping Cart

```javascript
// Create a shopping cart with methods to add items and calculate total
const shoppingCart = {
  items: [],
  
  // Add a method to add items {name, price, quantity}
  addItem(name, price, quantity) {
    // Your code here
  },
  
  // Add a method to calculate the total
  getTotal() {
    // Your code here
  }
};

shoppingCart.addItem("Book", 15, 2);
shoppingCart.addItem("Pen", 3, 5);
console.log(shoppingCart.getTotal()); // Should be 45

// ***
// Test: These tests will FAIL until you implement the methods
if (shoppingCart.items.length !== 2) {
  throw new Error(`Cart should have 2 items, has ${shoppingCart.items.length}`);
}
if (shoppingCart.getTotal() !== 45) {
  throw new Error(`Total should be 45, got ${shoppingCart.getTotal()}`);
}
// Verify items were added correctly
if (!shoppingCart.items.find(item => item.name === "Book" && item.price === 15 && item.quantity === 2)) {
  throw new Error("Book not added correctly to cart");
}
// ---
// Step 1: Implement addItem method
const shoppingCart = {
  items: [],
  
  addItem(name, price, quantity) {
    this.items.push({ name, price, quantity });
  },
  
  getTotal() {
    // TODO: implement this
    return 0;
  }
};

shoppingCart.addItem("Book", 15, 2);
shoppingCart.addItem("Pen", 3, 5);
console.log(shoppingCart.items);
// [{name: "Book", price: 15, quantity: 2}, {name: "Pen", price: 3, quantity: 5}]

// ***
// Test: Items should be added correctly
if (shoppingCart.items.length !== 2) {
  throw new Error(`Expected 2 items, got ${shoppingCart.items.length}`);
}
if (shoppingCart.items[0].name !== "Book" || shoppingCart.items[0].price !== 15 || shoppingCart.items[0].quantity !== 2) {
  throw new Error("First item not added correctly");
}
if (shoppingCart.getTotal() !== 0) {
  throw new Error("getTotal should return 0 when not implemented");
}
// ---
// Step 2: Implement getTotal using reduce
const shoppingCart = {
  items: [],
  
  addItem(name, price, quantity) {
    this.items.push({ name, price, quantity });
  },
  
  getTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.price * item.quantity);
    }, 0);
  }
};

shoppingCart.addItem("Book", 15, 2);  // 30
shoppingCart.addItem("Pen", 3, 5);    // 15
console.log(shoppingCart.getTotal()); // 45

// ***
// Test: Total calculation
if (shoppingCart.getTotal() !== 45) {
  throw new Error(`Expected total of 45, got ${shoppingCart.getTotal()}`);
}
// Test empty cart
const emptyCart = { items: [], getTotal: shoppingCart.getTotal };
if (emptyCart.getTotal() !== 0) {
  throw new Error("Empty cart should have total of 0");
}
// Test single item
const singleItemCart = {
  items: [{name: "Test", price: 10, quantity: 3}],
  getTotal: shoppingCart.getTotal
};
if (singleItemCart.getTotal() !== 30) {
  throw new Error("Single item calculation failed");
}
// ---
// Step 3: Add removeItem and item count methods
const shoppingCart = {
  items: [],
  
  addItem(name, price, quantity) {
    this.items.push({ name, price, quantity });
  },
  
  removeItem(name) {
    this.items = this.items.filter(item => item.name !== name);
  },
  
  getTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.price * item.quantity);
    }, 0);
  },
  
  getItemCount() {
    return this.items.reduce((count, item) => count + item.quantity, 0);
  }
};

shoppingCart.addItem("Book", 15, 2);
shoppingCart.addItem("Pen", 3, 5);
console.log(shoppingCart.getItemCount()); // 7
shoppingCart.removeItem("Pen");
console.log(shoppingCart.getTotal());     // 30

// ***
// Test: Full functionality
if (shoppingCart.getItemCount() !== 2) {
  throw new Error(`Expected 2 items after removal, got ${shoppingCart.getItemCount()}`);
}
if (shoppingCart.getTotal() !== 30) {
  throw new Error(`Expected total of 30 after removal, got ${shoppingCart.getTotal()}`);
}
// Test removing non-existent item
shoppingCart.removeItem("NonExistent");
if (shoppingCart.items.length !== 1) {
  throw new Error("Removing non-existent item should not affect cart");
}
// Test edge cases
shoppingCart.addItem("Free", 0, 10);
if (shoppingCart.getTotal() !== 30) {
  throw new Error("Free items should not affect total");
}
if (shoppingCart.getItemCount() !== 12) {
  throw new Error("Free items should count towards item count");
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Arrays: Lists of Data

```javascript
const numbers = [1, 2, 3, 4, 5];

// Common array methods
numbers.push(6);                    // Add to end
numbers.pop();                      // Remove from end
numbers.unshift(0);                 // Add to beginning
numbers.shift();                    // Remove from beginning

// Functional methods
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((acc, n) => acc + n, 0);

// Destructuring
const [first, second, ...rest] = numbers;
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Array Transformation

```javascript
// Transform an array of prices to include tax and format as strings
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

// Goal: ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"]

// Your code here
const result = []; // Replace with your implementation
console.log(result);

// ***
// Test: These tests will FAIL until you implement the solution
const expected = ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"];
if (result.length !== expected.length) {
  throw new Error(`Expected ${expected.length} items, got ${result.length}`);
}
for (let i = 0; i < expected.length; i++) {
  if (result[i] !== expected[i]) {
    throw new Error(`Expected "${expected[i]}" at index ${i}, got "${result[i] || 'undefined'}"`);
  }
}
// ---
// Step 1: Use map to calculate tax
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

const pricesWithTax = prices.map(price => {
  return price + (price * TAX_RATE);
});

console.log(pricesWithTax);
// [10.8, 27, 32.4, 16.2, 43.2]

// ***
// Test: Check tax calculations
const expected = [10.8, 27, 32.4, 16.2, 43.2];
if (pricesWithTax.length !== expected.length) {
  throw new Error("Array length mismatch");
}
for (let i = 0; i < expected.length; i++) {
  if (Math.abs(pricesWithTax[i] - expected[i]) > 0.001) {
    throw new Error(`Expected ${expected[i]} but got ${pricesWithTax[i]} at index ${i}`);
  }
}
// ---
// Step 2: Format as currency strings
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

const formattedPrices = prices.map(price => {
  const withTax = price + (price * TAX_RATE);
  return `$${withTax.toFixed(2)}`;
});

console.log(formattedPrices);
// ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"]

// ***
// Test: Check formatted output
const expectedFormatted = ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"];
if (JSON.stringify(formattedPrices) !== JSON.stringify(expectedFormatted)) {
  throw new Error(`Expected ${JSON.stringify(expectedFormatted)} but got ${JSON.stringify(formattedPrices)}`);
}
// Test edge cases
const edgeCase = [0, 0.01, 99.99];
const edgeResult = edgeCase.map(p => `$${(p * 1.08).toFixed(2)}`);
if (edgeResult[0] !== "$0.00") {
  throw new Error("Zero should format as $0.00");
}
// ---
// Step 3: Chain with filter for prices over $20
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

const expensiveItems = prices
  .map(price => price + (price * TAX_RATE))
  .filter(price => price > 20)
  .map(price => `$${price.toFixed(2)}`);

console.log(expensiveItems);
// ["$27.00", "$32.40", "$43.20"]

// ***
// Test: Check filtered results
const expectedExpensive = ["$27.00", "$32.40", "$43.20"];
if (JSON.stringify(expensiveItems) !== JSON.stringify(expectedExpensive)) {
  throw new Error(`Expected ${JSON.stringify(expectedExpensive)} but got ${JSON.stringify(expensiveItems)}`);
}
// Test that we correctly filtered out items <= $20
const allPricesWithTax = prices.map(p => p * 1.08);
const under20Count = allPricesWithTax.filter(p => p <= 20).length;
if (under20Count + expensiveItems.length !== prices.length) {
  throw new Error("Filter logic error: some items were lost");
}
```
</SlideLayout.Center>

<SlideLayout.Full>
## The DOM: Bringing Pages to Life
```javascript
// Selecting elements
const button = document.querySelector("#myButton");
const divs = document.querySelectorAll("div");

// Modifying elements
button.textContent = "Click me!";
button.style.backgroundColor = "blue";
button.classList.add("active");

// Event handling
button.addEventListener("click", (event) => {
  console.log("Button clicked!");
  event.target.disabled = true;
});

// Creating elements
const newDiv = document.createElement("div");
newDiv.innerHTML = "<p>Hello World!</p>";
document.body.appendChild(newDiv);
```
</SlideLayout.Full>

<SlideLayout.Center>
## Exercise: Interactive Todo List

```javascript
// Create a simple todo list with add and remove functionality
// HTML: <input id="todoInput"> <button id="addBtn">Add</button> <ul id="todoList"></ul>

// Mock DOM for testing
document.body.innerHTML = `
  <input id="todoInput" value="Test Todo">
  <button id="addBtn">Add</button>
  <ul id="todoList"></ul>
`;

const input = document.querySelector("#todoInput");
const addBtn = document.querySelector("#addBtn");
const todoList = document.querySelector("#todoList");

// Add event listener to button
addBtn.addEventListener("click", () => {
  // Your code here: create li, add text, add delete button
});

// Simulate a click to test
addBtn.click();

// ***
// Test: These tests will FAIL until you implement the todo functionality
if (todoList.children.length !== 1) {
  throw new Error(`Should have 1 todo after clicking, has ${todoList.children.length}`);
}
if (todoList.children[0].textContent !== "Test Todo") {
  throw new Error(`Todo should contain "Test Todo", got "${todoList.children[0]?.textContent || 'nothing'}"`);
}
if (input.value !== "") {
  throw new Error("Input should be cleared after adding todo");
}
// ---
// Step 1: Create and add todo items
document.body.innerHTML = `
  <input id="todoInput" value="Test Todo">
  <button id="addBtn">Add</button>
  <ul id="todoList"></ul>
`;

const input = document.querySelector("#todoInput");
const addBtn = document.querySelector("#addBtn");
const todoList = document.querySelector("#todoList");

addBtn.addEventListener("click", () => {
  const todoText = input.value.trim();
  if (todoText === "") return;
  
  // Create list item
  const li = document.createElement("li");
  li.textContent = todoText;
  
  // Add to list and clear input
  todoList.appendChild(li);
  input.value = "";
});

// Simulate click
addBtn.click();

// ***
// Test: Basic functionality
if (todoList.children.length !== 1) {
  throw new Error("Should have 1 todo item after clicking add");
}
if (todoList.children[0].textContent !== "Test Todo") {
  throw new Error("Todo item text incorrect");
}
if (input.value !== "") {
  throw new Error("Input should be cleared after adding");
}
// Test empty input
input.value = "";
addBtn.click();
if (todoList.children.length !== 1) {
  throw new Error("Should not add empty todos");
}
// ---
// Step 2: Add delete buttons to each todo
document.body.innerHTML = `
  <input id="todoInput" value="Test Todo">
  <button id="addBtn">Add</button>
  <ul id="todoList"></ul>
`;

const input = document.querySelector("#todoInput");
const addBtn = document.querySelector("#addBtn");
const todoList = document.querySelector("#todoList");

addBtn.addEventListener("click", () => {
  const todoText = input.value.trim();
  if (todoText === "") return;
  
  const li = document.createElement("li");
  li.textContent = todoText;
  
  // Create delete button
  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "Delete";
  deleteBtn.addEventListener("click", () => {
    li.remove();
  });
  
  li.appendChild(deleteBtn);
  todoList.appendChild(li);
  input.value = "";
});

// Add a todo
addBtn.click();

// ***
// Test: Delete functionality
if (todoList.children.length !== 1) {
  throw new Error("Should have 1 todo item");
}
const deleteBtn = todoList.querySelector("button");
if (!deleteBtn || deleteBtn.textContent !== "Delete") {
  throw new Error("Delete button not found or has wrong text");
}
// Click delete
deleteBtn.click();
if (todoList.children.length !== 0) {
  throw new Error("Todo should be removed after clicking delete");
}
// ---
// Step 3: Add enter key support and styling
document.body.innerHTML = `
  <input id="todoInput" value="Test Todo">
  <button id="addBtn">Add</button>
  <ul id="todoList"></ul>
`;

const input = document.querySelector("#todoInput");
const addBtn = document.querySelector("#addBtn");
const todoList = document.querySelector("#todoList");
let addCount = 0;

function addTodo() {
  const todoText = input.value.trim();
  if (todoText === "") return;
  
  addCount++;
  
  const li = document.createElement("li");
  li.style.marginBottom = "10px";
  
  const span = document.createElement("span");
  span.textContent = todoText;
  span.style.marginRight = "10px";
  
  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "Delete";
  deleteBtn.style.marginLeft = "auto";
  deleteBtn.addEventListener("click", () => li.remove());
  
  li.appendChild(span);
  li.appendChild(deleteBtn);
  todoList.appendChild(li);
  input.value = "";
  input.focus();
}

addBtn.addEventListener("click", addTodo);
input.addEventListener("keypress", (e) => {
  if (e.key === "Enter") addTodo();
});

// Test click
addBtn.click();

// Test enter key
input.value = "Another Todo";
const enterEvent = new KeyboardEvent("keypress", { key: "Enter" });
input.dispatchEvent(enterEvent);

// ***
// Test: Enhanced functionality
if (addCount !== 2) {
  throw new Error(`Expected 2 todos added, got ${addCount}`);
}
if (todoList.children.length !== 2) {
  throw new Error("Should have 2 todo items");
}
// Check structure
const firstTodo = todoList.children[0];
if (firstTodo.querySelector("span").textContent !== "Test Todo") {
  throw new Error("Todo text should be in span element");
}
if (firstTodo.style.marginBottom !== "10px") {
  throw new Error("Todo should have margin styling");
}
// Test focus
if (document.activeElement !== input) {
  throw new Error("Input should be focused after adding todo");
}
```
</SlideLayout.Center>

<SlideLayout.Full>
## JavaScript's Event Loop
  <FlexBox alignItems="center" justifyContent="center" flexDirection="row">
    <Image src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZmFqM2x1NW84NjcxaXczNHYzbjZwbm5mbTh3ZmIwMGg5MGo4bHJnaSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/CHtJn4SZurPa5LtV2w/giphy.gif" />
    - JavaScript is single-threaded but non-blocking
    - The event loop handles asynchronous operations
    - Callbacks, promises, and async/await manage async code
    - Understanding async is crucial for modern JavaScript
    </FlexBox>
</SlideLayout.Full>

<SlideLayout.Center>
## Asynchronous JavaScript

```javascript
// Callbacks (old way)
setTimeout(() => {
  console.log("After 1 second");
}, 1000);

// Promises
fetch("/api/users")
  .then(response => response.json())
  .then(users => console.log(users))
  .catch(error => console.error(error));

// Async/Await (modern way)
async function getUsers() {
  try {
    const response = await fetch("/api/users");
    const users = await response.json();
    console.log(users);
  } catch (error) {
    console.error(error);
  }
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Promise Chain to Async/Await

```javascript
// Convert this promise chain to async/await
function getUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(user => {
      return fetch(`/api/posts?userId=${user.id}`);
    })
    .then(response => response.json())
    .then(posts => {
      console.log(posts);
      return posts;
    })
    .catch(error => {
      console.error("Error:", error);
    });
}

// Mock fetch for testing
globalThis.fetch = (url) => {
  if (url.includes('/api/users/')) {
    return Promise.resolve({
      json: () => Promise.resolve({ id: 123, name: "Test User" })
    });
  } else if (url.includes('/api/posts')) {
    return Promise.resolve({
      json: () => Promise.resolve([{ id: 1, title: "Post 1" }])
    });
  }
};

// Call the function
const result = getUserData(1);

// ***
// Test: This will FAIL if you convert to async/await incorrectly
// The function should still work exactly the same way
result.then(posts => {
  if (!Array.isArray(posts) || posts.length === 0) {
    throw new Error("Should return an array of posts");
  }
  if (posts[0].title !== "Post 1") {
    throw new Error(`Expected post title "Post 1", got "${posts[0]?.title}"`);
  }
}).catch(error => {
  throw new Error(`Function failed: ${error.message}`);
});
// ---
// Step 1: Create async function wrapper
async function getUserData(userId) {
  // We'll convert the promise chain here
  return fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(user => {
      return fetch(`/api/posts?userId=${user.id}`);
    })
    .then(response => response.json())
    .then(posts => {
      console.log(posts);
      return posts;
    })
    .catch(error => {
      console.error("Error:", error);
    });
}

// Mock fetch
globalThis.fetch = (url) => {
  if (url.includes('/api/users/')) {
    return Promise.resolve({
      json: () => Promise.resolve({ id: 123, name: "Test User" })
    });
  } else if (url.includes('/api/posts')) {
    return Promise.resolve({
      json: () => Promise.resolve([{ id: 1, title: "Post 1" }])
    });
  }
};

// ***
// Test: Async function should still work
getUserData(1).then(posts => {
  if (!Array.isArray(posts)) {
    throw new Error("Should return array of posts");
  }
}).catch(e => {
  throw new Error("Function failed: " + e.message);
});
// ---
// Step 2: Replace first .then with await
async function getUserData(userId) {
  try {
    const userResponse = await fetch(`/api/users/${userId}`);
    const user = await userResponse.json();
    
    // Still need to convert the rest
    return fetch(`/api/posts?userId=${user.id}`)
      .then(response => response.json())
      .then(posts => {
        console.log(posts);
        return posts;
      });
  } catch (error) {
    console.error("Error:", error);
  }
}

// Mock fetch
globalThis.fetch = (url) => {
  if (url.includes('/api/users/')) {
    return Promise.resolve({
      json: () => Promise.resolve({ id: 123, name: "Test User" })
    });
  } else if (url.includes('/api/posts')) {
    return Promise.resolve({
      json: () => Promise.resolve([{ id: 1, title: "Post 1" }])
    });
  }
};

// ***
// Test: Partially converted function
getUserData(1).then(posts => {
  if (!posts || !Array.isArray(posts)) {
    throw new Error("Partial conversion broke the function");
  }
});
// ---
// Step 3: Complete async/await conversion
async function getUserData(userId) {
  try {
    // Get user data
    const userResponse = await fetch(`/api/users/${userId}`);
    const user = await userResponse.json();
    
    // Get user's posts
    const postsResponse = await fetch(`/api/posts?userId=${user.id}`);
    const posts = await postsResponse.json();
    
    console.log(posts);
    return posts;
  } catch (error) {
    console.error("Error:", error);
    throw error; // Re-throw to maintain error propagation
  }
}

// Mock fetch with error case
globalThis.fetch = (url) => {
  if (url.includes('/api/users/999')) {
    return Promise.reject(new Error("User not found"));
  }
  if (url.includes('/api/users/')) {
    return Promise.resolve({
      json: () => Promise.resolve({ id: 123, name: "Test User" })
    });
  } else if (url.includes('/api/posts')) {
    return Promise.resolve({
      json: () => Promise.resolve([{ id: 1, title: "Post 1" }])
    });
  }
};

// ***
// Test: Full async/await conversion
getUserData(1).then(posts => {
  if (!Array.isArray(posts) || posts.length === 0) {
    throw new Error("Should return posts array");
  }
}).catch(e => {
  throw new Error("Unexpected error: " + e.message);
});

// Test error handling
getUserData(999).then(() => {
  throw new Error("Should have thrown an error for user 999");
}).catch(e => {
  if (!e.message.includes("User not found")) {
    throw new Error("Error not properly propagated");
  }
  // Error caught as expected
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Modern JavaScript Features

```javascript
// Template literals
const greeting = `Hello, ${name}!`;

// Optional chaining
const city = user?.address?.city ?? "Unknown";

// Nullish coalescing
const port = process.env.PORT ?? 3000;

// Dynamic imports
const module = await import("./module.js");

// Private class fields
class User {
  #password;  // Private field
  
  constructor(password) {
    this.#password = password;
  }
}
```
</SlideLayout.Center>

<SlideLayout.Center>
## JavaScript Ecosystem

- **Package Manager**: npm, yarn, pnpm
- **Bundlers**: Webpack, Vite, Parcel, esbuild
- **Frontend Frameworks**: React, Vue, Angular, Svelte
- **Server Frameworks**: Express, Koa, Fastify, NextJS
- **Runtime Environments**: Node.js, Deno, Bun
- **Testing**: Jest, Mocha, Vitest
- **Linting**: ESLint, Prettier
</SlideLayout.Center>

<SlideLayout.Center>
## Common Pitfalls

```javascript
// Equality confusion
console.log(0 == false);    // true (loose equality)
console.log(0 === false);   // false (strict equality)

// Floating point precision
console.log(0.1 + 0.2);     // 0.30000000000000004

// Array/Object references
const arr1 = [1, 2, 3];
const arr2 = arr1;
arr2.push(4);
console.log(arr1);          // [1, 2, 3, 4]

// "this" binding
const obj = {
  name: "Object",
  greet: function() {
    setTimeout(function() {
      console.log(this.name); // undefined!
    }, 1000);
  }
};
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Fix the "this" Problem

```javascript
// Fix the code so it prints countdown from 5 to 0, then "Timer: Done!"
const timer = {
  name: "Timer",
  seconds: 5,
  outputs: [], // Track outputs for testing
  
  start() {
    const interval = setInterval(function() {
      console.log(this.seconds); // undefined!
      this.seconds--;
      
      if (this.seconds < 0) {
        clearInterval(interval);
        console.log(this.name + ": Done!"); // undefined: Done!
      }
    }, 100); // Faster for testing
  }
};

timer.start();

// ***
// Test: These will FAIL because 'this' is undefined in the callback
setTimeout(() => {
  // The timer should have counted down
  if (timer.seconds === 5) {
    throw new Error("Timer didn't run - 'this' was undefined in the callback");
  }
  // In the broken version, timer.seconds stays at 5
  if (timer.seconds < 0) {
    throw new Error("This test shouldn't pass with the broken code!");
  }
}, 700);
// ---
// Step 1: Store reference to 'this'
const timer = {
  name: "Timer",
  seconds: 5,
  outputs: [], // Track outputs for testing
  
  start() {
    const self = this; // Store reference
    const interval = setInterval(function() {
      console.log(self.seconds);
      self.outputs.push(self.seconds);
      self.seconds--;
      
      if (self.seconds < 0) {
        clearInterval(interval);
        console.log(self.name + ": Done!");
        self.outputs.push("done");
      }
    }, 100);
  }
};

timer.start(); // Works!

// ***
// Test: Verify countdown works
setTimeout(() => {
  if (timer.outputs.length < 6) {
    throw new Error("Timer didn't complete countdown");
  }
  if (timer.outputs[0] !== 5 || timer.outputs[5] !== 0) {
    throw new Error("Timer didn't count down correctly");
  }
  if (timer.outputs[6] !== "done") {
    throw new Error("Timer didn't complete");
  }
}, 700);
// ---
// Step 2: Use arrow function (preserves 'this')
const timer = {
  name: "Timer",
  seconds: 5,
  outputs: [],
  
  start() {
    const interval = setInterval(() => {  // Arrow function
      console.log(this.seconds);
      this.outputs.push(this.seconds);
      this.seconds--;
      
      if (this.seconds < 0) {
        clearInterval(interval);
        console.log(this.name + ": Done!");
        this.outputs.push("done");
      }
    }, 100);
  }
};

timer.start(); // Works perfectly!

// ***
// Test: Arrow function solution
setTimeout(() => {
  if (timer.outputs[timer.outputs.length - 1] !== "done") {
    throw new Error("Arrow function solution failed");
  }
  // Test that 'this' correctly refers to timer object
  if (!timer.outputs.includes(5) || !timer.outputs.includes(0)) {
    throw new Error("Countdown sequence incorrect");
  }
}, 700);
// ---
// Step 3: Using bind() method
const timer = {
  name: "Timer",
  seconds: 5,
  outputs: [],
  
  start() {
    const interval = setInterval(function() {
      console.log(this.seconds);
      this.outputs.push(this.seconds);
      this.seconds--;
      
      if (this.seconds < 0) {
        clearInterval(interval);
        console.log(this.name + ": Done!");
        this.outputs.push(this.name); // Store name to verify 'this'
      }
    }.bind(this), 100);  // Bind 'this' context
  }
};

timer.start(); // Also works!

// ***
// Test: bind() solution
setTimeout(() => {
  const lastOutput = timer.outputs[timer.outputs.length - 1];
  if (lastOutput !== "Timer") {
    throw new Error(`bind() failed - expected "Timer", got "${lastOutput}"`);
  }
  // Verify all three solutions produce same countdown
  if (timer.outputs.filter(x => typeof x === 'number').length !== 6) {
    throw new Error("Should have 6 countdown numbers");
  }
}, 700);
```
</SlideLayout.Center>

<SlideLayout.Center>
## Best Practices

- Use `const` by default, `let` when needed, avoid `var`
- Always use strict equality (`===`)
- Use descriptive variable and function names
- Keep functions small and focused
- Handle errors properly with try/catch
- Use modern ES6+ features
- Lint and format your code consistently
- Write tests for your code
</SlideLayout.Center>

<SlideLayout.Center>
## The Future of JavaScript

- **Temporal API**: Better date/time handling
- **Records & Tuples**: Immutable data structures
- **Pattern Matching**: More expressive conditionals
- **Type Annotations**: Optional static types
- **Pipeline Operator**: Functional composition
- **Decorators**: Metaprogramming capabilities
</SlideLayout.Center>

<SlideLayout.HorizontalImage 
  title="Ready to Code?" 
  src="https://media1.giphy.com/media/LmNwrBhejkK9EFP504/giphy.gif"
  listItems={[
    'JavaScript is powerful and flexible',
    'Start with the basics, master them well',
    'Practice, practice, practice!',
    'The community is here to help'
  ]}
/>