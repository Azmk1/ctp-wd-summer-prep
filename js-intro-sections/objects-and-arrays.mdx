import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## Objects: JavaScript's Building Blocks

```javascript
// Object literal
const user = {
  name: "John",
  age: 25,
  greet() {
    return `Hi, I'm ${this.name}`;
  }
};

// Accessing properties
console.log(user.name);      // Dot notation
console.log(user["age"]);    // Bracket notation

// Destructuring (ES6+)
const { name, age } = user;

// Spread operator (ES6+)
const updatedUser = { ...user, age: 26 };
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Building a Shopping Cart

```javascript
// Test setup
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Create a shopping cart with methods to add items and calculate total
const shoppingCart = {
  items: [],
  
  // Add a method to add items {name, price, quantity}
  addItem(name, price, quantity) {
    // Your code here
  },
  
  // Add a method to calculate the total
  getTotal() {
    // Your code here
  }
};

shoppingCart.addItem("Book", 15, 2);
shoppingCart.addItem("Pen", 3, 5);
console.log(shoppingCart.getTotal()); // Should be 45

//***
describe('Shopping Cart - Initial Implementation', () => {
  it('should add items to the cart', () => {
    expect(shoppingCart.items).to.have.lengthOf(2);
  });
  
  it('should store correct item details', () => {
    const book = shoppingCart.items.find(item => item.name === "Book");
    expect(book).to.exist;
    expect(book.price).to.equal(15);
    expect(book.quantity).to.equal(2);
    
    const pen = shoppingCart.items.find(item => item.name === "Pen");
    expect(pen).to.exist;
    expect(pen.price).to.equal(3);
    expect(pen.quantity).to.equal(5);
  });
  
  it('should calculate the correct total', () => {
    const total = shoppingCart.getTotal();
    expect(total).to.equal(45);
  });
  
  it('should log the total', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.equal(45);
  });
});
// ---
// Test setup (reuse)
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 1: Implement addItem method
const shoppingCart = {
  items: [],
  
  addItem(name, price, quantity) {
    this.items.push({ name, price, quantity });
  },
  
  getTotal() {
    // TODO: implement this
    return 0;
  }
};

shoppingCart.addItem("Book", 15, 2);
shoppingCart.addItem("Pen", 3, 5);
console.log(shoppingCart.items);
// [{name: "Book", price: 15, quantity: 2}, {name: "Pen", price: 3, quantity: 5}]

//***
describe('Shopping Cart - Step 1: addItem', () => {
  it('should add items to the cart array', () => {
    expect(shoppingCart.items).to.have.lengthOf(2);
  });
  
  it('should add items with correct structure', () => {
    const [book, pen] = shoppingCart.items;
    
    expect(book).to.deep.equal({
      name: "Book",
      price: 15,
      quantity: 2
    });
    
    expect(pen).to.deep.equal({
      name: "Pen",
      price: 3,
      quantity: 5
    });
  });
  
  it('should return 0 from unimplemented getTotal', () => {
    expect(shoppingCart.getTotal()).to.equal(0);
  });
  
  it('should log the items array', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.deep.equal(shoppingCart.items);
  });
});
// ---
// Test setup (reuse)
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 2: Implement getTotal using reduce
const shoppingCart = {
  items: [],
  
  addItem(name, price, quantity) {
    this.items.push({ name, price, quantity });
  },
  
  getTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.price * item.quantity);
    }, 0);
  }
};

shoppingCart.addItem("Book", 15, 2);  // 30
shoppingCart.addItem("Pen", 3, 5);    // 15
console.log(shoppingCart.getTotal()); // 45

//***
describe('Shopping Cart - Step 2: getTotal', () => {
  it('should calculate total correctly', () => {
    expect(shoppingCart.getTotal()).to.equal(45);
  });
  
  it('should handle empty cart', () => {
    const emptyCart = { 
      items: [], 
      getTotal: shoppingCart.getTotal 
    };
    expect(emptyCart.getTotal()).to.equal(0);
  });
  
  it('should calculate single item correctly', () => {
    const singleItemCart = {
      items: [{name: "Test", price: 10, quantity: 3}],
      getTotal: shoppingCart.getTotal
    };
    expect(singleItemCart.getTotal()).to.equal(30);
  });
  
  it('should handle decimal prices', () => {
    const decimalCart = {
      items: [
        {name: "Item1", price: 9.99, quantity: 2},
        {name: "Item2", price: 0.50, quantity: 10}
      ],
      getTotal: shoppingCart.getTotal
    };
    expect(decimalCart.getTotal()).to.be.closeTo(24.98, 0.01);
  });
  
  it('should log the total', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.equal(45);
  });
});
// ---
// Test setup (reuse)
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 3: Add removeItem and item count methods
const shoppingCart = {
  items: [],
  
  addItem(name, price, quantity) {
    this.items.push({ name, price, quantity });
  },
  
  removeItem(name) {
    this.items = this.items.filter(item => item.name !== name);
  },
  
  getTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.price * item.quantity);
    }, 0);
  },
  
  getItemCount() {
    return this.items.reduce((count, item) => count + item.quantity, 0);
  }
};

shoppingCart.addItem("Book", 15, 2);
shoppingCart.addItem("Pen", 3, 5);
console.log(shoppingCart.getItemCount()); // 7
shoppingCart.removeItem("Pen");
console.log(shoppingCart.getTotal());     // 30

//***
describe('Shopping Cart - Step 3: Full functionality', () => {
  it('should count items correctly', () => {
    // Initial state after removal
    expect(shoppingCart.getItemCount()).to.equal(2);
  });
  
  it('should calculate total after removal', () => {
    expect(shoppingCart.getTotal()).to.equal(30);
  });
  
  it('should handle removing non-existent items', () => {
    const initialLength = shoppingCart.items.length;
    shoppingCart.removeItem("NonExistent");
    expect(shoppingCart.items.length).to.equal(initialLength);
  });
  
  it('should handle free items correctly', () => {
    shoppingCart.addItem("Free", 0, 10);
    expect(shoppingCart.getTotal()).to.equal(30, "Free items should not affect total");
    expect(shoppingCart.getItemCount()).to.equal(12, "Free items should count towards item count");
  });
  
  it('should log item count and total', () => {
    expect(logSpy.calledTwice).to.be.true;
    expect(logSpy.firstCall.args[0]).to.equal(7);
    expect(logSpy.secondCall.args[0]).to.equal(30);
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Arrays: Lists of Data

```javascript
const numbers = [1, 2, 3, 4, 5];

// Common array methods
numbers.push(6);                    // Add to end
numbers.pop();                      // Remove from end
numbers.unshift(0);                 // Add to beginning
numbers.shift();                    // Remove from beginning

// Functional methods
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((acc, n) => acc + n, 0);

// Destructuring
const [first, second, ...rest] = numbers;
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Array Transformation

```javascript
// Test setup
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Transform an array of prices to include tax and format as strings
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

// Goal: ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"]

// Your code here
const result = []; // Replace with your implementation
console.log(result);

//***
describe('Array Transformation - Initial', () => {
  const expected = ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"];
  
  it('should return an array with correct length', () => {
    expect(result).to.be.an('array');
    expect(result).to.have.lengthOf(expected.length);
  });
  
  it('should format each price correctly with tax', () => {
    expected.forEach((expectedValue, index) => {
      expect(result[index]).to.equal(expectedValue);
    });
  });
  
  it('should log the result', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.deep.equal(result);
  });
});
// ---
// Test setup (reuse)
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 1: Use map to calculate tax
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

const pricesWithTax = prices.map(price => {
  return price + (price * TAX_RATE);
});

console.log(pricesWithTax);
// [10.8, 27, 32.4, 16.2, 43.2]

//***
describe('Array Transformation - Step 1: Calculate tax', () => {
  const expected = [10.8, 27, 32.4, 16.2, 43.2];
  
  it('should calculate tax for each price', () => {
    expect(pricesWithTax).to.have.lengthOf(expected.length);
    
    expected.forEach((expectedValue, index) => {
      expect(pricesWithTax[index]).to.be.closeTo(expectedValue, 0.001);
    });
  });
  
  it('should preserve original array', () => {
    expect(prices).to.deep.equal([10, 25, 30, 15, 40]);
  });
  
  it('should log the calculated values', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.deep.equal(pricesWithTax);
  });
});
// ---
// Test setup (reuse)
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 2: Format as currency strings
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

const formattedPrices = prices.map(price => {
  const withTax = price + (price * TAX_RATE);
  return `$${withTax.toFixed(2)}`;
});

console.log(formattedPrices);
// ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"]

//***
describe('Array Transformation - Step 2: Format as currency', () => {
  const expectedFormatted = ["$10.80", "$27.00", "$32.40", "$16.20", "$43.20"];
  
  it('should format prices as currency strings', () => {
    expect(formattedPrices).to.deep.equal(expectedFormatted);
  });
  
  it('should handle edge cases correctly', () => {
    const edgeCase = [0, 0.01, 99.99];
    const edgeResult = edgeCase.map(p => `$${(p * 1.08).toFixed(2)}`);
    
    expect(edgeResult[0]).to.equal("$0.00");
    expect(edgeResult[1]).to.equal("$0.01");
    expect(edgeResult[2]).to.equal("$107.99");
  });
  
  it('should log the formatted prices', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.deep.equal(formattedPrices);
  });
});
// ---
// Test setup (reuse)
let logSpy;

before(() => {
  logSpy = sinon.spy(console, 'log');
});

afterEach(() => {
  logSpy.resetHistory();
});

after(() => {
  logSpy.restore();
});

//***
// Step 3: Chain with filter for prices over $20
const prices = [10, 25, 30, 15, 40];
const TAX_RATE = 0.08;

const expensiveItems = prices
  .map(price => price + (price * TAX_RATE))
  .filter(price => price > 20)
  .map(price => `$${price.toFixed(2)}`);

console.log(expensiveItems);
// ["$27.00", "$32.40", "$43.20"]

//***
describe('Array Transformation - Step 3: Filter and chain', () => {
  const expectedExpensive = ["$27.00", "$32.40", "$43.20"];
  
  it('should filter and format expensive items', () => {
    expect(expensiveItems).to.deep.equal(expectedExpensive);
  });
  
  it('should correctly filter items over $20', () => {
    const allPricesWithTax = prices.map(p => p * 1.08);
    const under20Count = allPricesWithTax.filter(p => p <= 20).length;
    
    expect(under20Count + expensiveItems.length).to.equal(prices.length);
  });
  
  it('should use method chaining effectively', () => {
    // Verify that we got 3 items over $20
    expect(expensiveItems).to.have.lengthOf(3);
  });
  
  it('should log the filtered results', () => {
    expect(logSpy.calledOnce).to.be.true;
    expect(logSpy.firstCall.args[0]).to.deep.equal(expensiveItems);
  });
});
```
</SlideLayout.Center>