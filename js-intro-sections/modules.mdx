import { SlideLayout, Image, FlexBox, UnorderedList, ListItem, Box} from 'spectacle'

<SlideLayout.Center>
## JavaScript Modules

```javascript
// math.js - Named exports
export const PI = 3.14159;
export function add(a, b) {
  return a + b;
}
export function multiply(a, b) {
  return a * b;
}

// main.js - Importing
import { PI, add, multiply } from './math.js';
import * as math from './math.js'; // Import all

// Default export
export default class Calculator {
  // ...
}
import Calculator from './calculator.js';
```
</SlideLayout.Center>

<SlideLayout.Center>
## Exercise: Create a Module System

```javascript
// Create a user management module
// userModule.js
const users = [];
let nextId = 1;

// TODO: Create and export these functions:
// - createUser(name, email) - returns user object with id
// - getUser(id) - returns user or null
// - updateUser(id, updates) - updates user and returns it
// - deleteUser(id) - removes user, returns true/false
// - getAllUsers() - returns all users

// Export your functions here

// ***
const userModule = {
  createUser(name, email) {
    // Your implementation
  },
  getUser(id) {
    // Your implementation
  },
  getAllUsers() {
    // Your implementation
  }
};

describe('User Module - Initial Implementation', () => {
  let user1;
  
  before(() => {
    user1 = userModule.createUser('Alice', 'alice@example.com');
  });
  
  it('should create user with id and properties', () => {
    expect(user1).to.have.property('id');
    expect(user1.name).to.equal('Alice');
  });
  
  it('should retrieve the created user', () => {
    const retrieved = userModule.getUser(user1.id);
    expect(retrieved).to.equal(user1);
  });
});
// ---
// Step 1: Basic CRUD operations
const users = [];
let nextId = 1;

export function createUser(name, email) {
  const user = {
    id: nextId++,
    name,
    email,
    createdAt: new Date()
  };
  users.push(user);
  return user;
}

export function getUser(id) {
  return users.find(user => user.id === id) || null;
}

export function updateUser(id, updates) {
  const user = getUser(id);
  if (!user) return null;
  
  Object.assign(user, updates, {
    updatedAt: new Date()
  });
  return user;
}

export function deleteUser(id) {
  const index = users.findIndex(user => user.id === id);
  if (index === -1) return false;
  
  users.splice(index, 1);
  return true;
}

export function getAllUsers() {
  return [...users]; // Return copy to prevent external modification
}

// ***
describe('User Module - Step 1: CRUD operations', () => {
  let user1, user2;
  
  before(() => {
    user1 = createUser('Alice', 'alice@example.com');
    user2 = createUser('Bob', 'bob@example.com');
  });
  
  it('should have 2 users after creation', () => {
    expect(getAllUsers()).to.have.lengthOf(2);
  });
  
  it('should update user email', () => {
    const updated = updateUser(user1.id, { email: 'newalice@example.com' });
    expect(updated.email).to.equal('newalice@example.com');
  });
  
  it('should add updatedAt timestamp', () => {
    const updated = updateUser(user1.id, { email: 'newalice@example.com' });
    expect(updated.updatedAt).to.exist;
  });
  
  it('should delete user successfully', () => {
    const result = deleteUser(user2.id);
    expect(result).to.be.true;
  });
  
  it('should have 1 user after deletion', () => {
    expect(getAllUsers()).to.have.lengthOf(1);
  });
});
// ---
// Step 2: Add validation and error handling
const users = [];
let nextId = 1;

class ValidationError extends Error {
  constructor(field, message) {
    super(message);
    this.field = field;
    this.name = 'ValidationError';
  }
}

function validateEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

export function createUser(name, email) {
  // Validation
  if (!name || name.trim().length < 2) {
    throw new ValidationError('name', 'Name must be at least 2 characters');
  }
  if (!validateEmail(email)) {
    throw new ValidationError('email', 'Invalid email format');
  }
  
  // Check for duplicate email
  if (users.some(u => u.email === email)) {
    throw new ValidationError('email', 'Email already exists');
  }
  
  const user = {
    id: nextId++,
    name: name.trim(),
    email: email.toLowerCase(),
    createdAt: new Date(),
    active: true
  };
  users.push(user);
  return user;
}

export function getUser(id) {
  if (!id || typeof id !== 'number') {
    throw new ValidationError('id', 'Valid ID required');
  }
  return users.find(user => user.id === id) || null;
}

export function updateUser(id, updates) {
  const user = getUser(id);
  if (!user) return null;
  
  // Validate updates
  if (updates.email && !validateEmail(updates.email)) {
    throw new ValidationError('email', 'Invalid email format');
  }
  if (updates.name && updates.name.trim().length < 2) {
    throw new ValidationError('name', 'Name must be at least 2 characters');
  }
  
  // Check email uniqueness
  if (updates.email && updates.email !== user.email) {
    if (users.some(u => u.email === updates.email)) {
      throw new ValidationError('email', 'Email already exists');
    }
  }
  
  Object.assign(user, updates, {
    updatedAt: new Date()
  });
  return user;
}

export { ValidationError };

// ***
describe('User Module - Step 2: Validation', () => {
  it('should reject short names', () => {
    expect(() => createUser('A', 'alice@example.com')).to.throw(ValidationError)
      .with.property('field', 'name');
  });
  
  it('should reject invalid email', () => {
    expect(() => createUser('Alice', 'invalid-email')).to.throw(ValidationError)
      .with.property('field', 'email');
  });
  
  it('should reject duplicate email', () => {
    const user = createUser('Alice', 'alice@example.com');
    expect(() => createUser('Alice2', 'alice@example.com'))
      .to.throw(ValidationError)
      .with.property('field', 'email')
      .and.property('message').that.includes('exists');
  });
});
// ---
// Step 3: Add search and filter capabilities
// Complete module with advanced features
const users = new Map(); // Use Map for better performance
let nextId = 1;

export function createUser(name, email, role = 'user') {
  if (!name || name.trim().length < 2) {
    throw new ValidationError('name', 'Name must be at least 2 characters');
  }
  if (!validateEmail(email)) {
    throw new ValidationError('email', 'Invalid email format');
  }
  
  // Check duplicate with Map
  for (const user of users.values()) {
    if (user.email === email) {
      throw new ValidationError('email', 'Email already exists');
    }
  }
  
  const user = {
    id: nextId++,
    name: name.trim(),
    email: email.toLowerCase(),
    role,
    createdAt: new Date(),
    active: true,
    loginCount: 0,
    lastLogin: null
  };
  
  users.set(user.id, user);
  return { ...user }; // Return copy
}

export function searchUsers(query) {
  const lowerQuery = query.toLowerCase();
  return Array.from(users.values()).filter(user => 
    user.name.toLowerCase().includes(lowerQuery) ||
    user.email.toLowerCase().includes(lowerQuery)
  );
}

export function getUsersByRole(role) {
  return Array.from(users.values()).filter(user => user.role === role);
}

export function getActiveUsers() {
  return Array.from(users.values()).filter(user => user.active);
}

export function recordLogin(id) {
  const user = users.get(id);
  if (!user) return null;
  
  user.loginCount++;
  user.lastLogin = new Date();
  return { ...user };
}

export function deactivateUser(id) {
  const user = users.get(id);
  if (!user) return false;
  
  user.active = false;
  user.deactivatedAt = new Date();
  return true;
}

export default {
  createUser,
  getUser: (id) => users.get(id) ? { ...users.get(id) } : null,
  updateUser,
  deleteUser: (id) => users.delete(id),
  getAllUsers: () => Array.from(users.values()).map(u => ({ ...u })),
  searchUsers,
  getUsersByRole,
  getActiveUsers,
  recordLogin,
  deactivateUser
};

// ***
describe('User Module - Step 3: Advanced features', () => {
  let admin, user1, user2;
  
  before(() => {
    admin = createUser('Admin', 'admin@example.com', 'admin');
    user1 = createUser('John Doe', 'john@example.com');
    user2 = createUser('Jane Smith', 'jane@example.com');
  });
  
  it('should search users by name', () => {
    const searchResults = searchUsers('john');
    expect(searchResults).to.have.lengthOf(1);
    expect(searchResults[0].email).to.equal('john@example.com');
  });
  
  it('should filter users by role', () => {
    const admins = getUsersByRole('admin');
    expect(admins).to.have.lengthOf(1);
    expect(admins[0].role).to.equal('admin');
  });
  
  it('should track login count and time', () => {
    recordLogin(user1.id);
    recordLogin(user1.id);
    const updated = users.get(user1.id);
    expect(updated.loginCount).to.equal(2);
    expect(updated.lastLogin).to.exist;
  });
  
  it('should deactivate users', () => {
    deactivateUser(user2.id);
    const activeUsers = getActiveUsers();
    expect(activeUsers).to.have.lengthOf(2);
  });
});
```
</SlideLayout.Center>

<SlideLayout.Center>
## Module Patterns

- **CommonJS** (Node.js): `require()` and `module.exports`
- **ES6 Modules**: `import` and `export` (modern standard)
- **AMD**: Asynchronous Module Definition (older browsers)
- **UMD**: Universal Module Definition (works everywhere)

Best practices:
- One module per file
- Clear, focused exports
- Avoid circular dependencies
- Use named exports for utilities
- Use default export for main functionality
</SlideLayout.Center>